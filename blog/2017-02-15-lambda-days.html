<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Lambda Days 2017 trip report</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href=".././blog/2017-02-15-lambda-days.md">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../blog/" class="thisPage">blog/</a></li><li><a href="../hacks/">hacks/</a></li><li><a href="../links.html">links</a></li><li><a href="../me/">me/</a></li><li><a href="../programs/">programs/</a></li><li><a href="../projects/">projects/</a></li><li><a href="../writings/">writings/</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1>Lambda Days 2017 trip report</h1>
<div class="postmetadata">
    Posted on February 15, 2017
</div>

<p>Last week, I attended the <a href="http://www.lambdadays.org/lambdadays2017">Lambda Days</a> conference in Krakow. I did not know about this conference until last years FHPC, where <a href="http://www.cse.chalmers.se/~rjmh/">John Hughes</a> suggested submissions to its research track. My colleagues also had not heard of this conference before. I feel this is obscurity is undeserved: Lambda Days was well organised and most presentations were quite good and on relevant topics. Apart from the research track, at which I presented <a href="https://futhark-lang.org">Futhark</a>, Lambda Days is an industrial conference, not an academic one. While I was unable to attend all presentations, I did attend several, which I will summarise below. I believe every talk was recorded on video, but at the time of this writing, recordings are not yet available.</p>
<p>Krakow itself was an unusually pretty city, and a welcome diversion from the urban horror of Brussels, which had been the scene for my <a href="http://sigkill.dk/blog/2017-02-06-fosdem.html">trip to FOSDEM</a>. I will definitely try to attend Lambda Days again next year.</p>
<h1 id="day-one"><a href="#day-one" id="day-one-link" class="titlelink" title="day-one">Day One</a></h1>
<p>The day opened with a keynote by John Hughes and Mary Sheeran, on <em>Why Functional Programming Matters</em>. There was little new in John’s part if you have already read <a href="http://worrydream.com/refs/Hughes-WhyFunctionalProgrammingMatters.pdf">his famous paper</a> or seen a previous presentation on the topic, but he was as always a highly engaging speaker. Mary’s part was more unfamiliar to me, as she spoke about functional hardware specifications. Mary also mentioned <a href="http://dl.acm.org/citation.cfm?id=359579">Backus’s famous Turing Award paper</a>. I was amused when she suggested skipping the latter half, which she said had not aged as well. This was exactly the impression I got when I read the paper myself. According to the keynote, the four principal concepts of functional programming are: <em>Programming with whole values</em>, having strong <em>combining forms</em>, possessing <em>simple laws</em>, and <em>using functions as representations</em>. No argument here (except I’ll say the latter often engenders far more trouble in practice than the former three).</p>
<p>I spent rest of the day attending the research track. the first presentation was on <a href="http://www.lambdadays.org/lambdadays2017/stanislaw-ambroszkiewicz">hardware realisations of functional specifications</a> (I think). The thesis seemed to be that first-order functions can be mapped directly to hardware, and with (future?) dynamically reconfigurable circuitry, so can higher-order functions. Unfortunately, the speaker failed to optimally utilise the microphone (to put it in diplomatic terms), and as a result, most of what was said could not be hard. While I hardly consider myself graceful with a microphone, I am grateful for my years in the student revue for teaching me the basics. Several in the audience rose and left as the microphone situation continued to deteriorate, which I found slightly rude.</p>
<p>Next talk was on <a href="http://www.lambdadays.org/lambdadays2017/kevin-hammond">automatically deriving parallel cost models</a>, but if I had to give my own summary, I would say that it was about making functions express their parallel structure in their types. The point is that this will allow callers to implement the parallel structure in whichever way they see fit, and have the types to guide and check them. The approach hinges on expressing parallelism through specific well-behaved recursion schemes. One main one seemed to be the hylomorphism; essentially generalised divide-and-conquer. This segued nicely into the next talk, which was on <a href="http://www.lambdadays.org/lambdadays2017/adam-d-barwell">automatically detecting such recursion schemes</a>. Combined with the previous work, this is essentially auto-parallelisation for functional languages! Although in contrast to the black-box behemoths found in the imperative world, the focus here is to aid the programmer in refactoring his program to obtain parallelism.</p>
<p>The <a href="http://www.lambdadays.org/lambdadays2017/niki-vazou">next talk</a> was on <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Liquid Haskell</a>; an effort to add refinement types to Haskell. In comparison with dependent types, refinement types are more limited, but with decidable type checking. The motivating example was Heartbleed-ish behaviour via the <code>Text.Unsafe</code> module, which did not seen very convincing to me. In this case, dynamic checks (which were explicitly disabled) would have been sufficient. The practical demonstration made the system seem surprisingly practical, though.</p>
<p>Next up was a person doing <a href="http://www.lambdadays.org/lambdadays2017/wojciech-turek">HPC traffic simulations in Erlang</a>. Never knew anyone ran Erlang on a supercomputer. The system seemed to scale well, but there was no comparison of absolute runtimes to non-Erlang implementations. The next talk was <a href="http://www.lambdadays.org/lambdadays2017/tamas-kozsik">on automatically detecting divide-and-conquer patterns in Erlang programs</a>, with the goal of refactoring for parallelism. sounds familiar.</p>
<p>We moved on to, as I understood it, <a href="http://www.lambdadays.org/lambdadays2017/daniel-rubio-bonilla">adding functional annotations to existing HPC code</a>. It looked vaguely like a functional version OpenMP. I spaced out a bit here, since I have a dire allergy against <a href="http://www.catb.org/jargon/html/D/dusty-deck.html">dusty deck</a> HPC code. The following talk seemed a bit oddly placed at the research track, as it was on <a href="http://www.lambdadays.org/lambdadays2017/nikhil-barthwal">how Jet.com had used F# to write hundreds of microservices</a>, although the presenter was decent. The final research talk was on <a href="http://www.lambdadays.org/lambdadays2017/annette-bieniusa">using Haskell Arrows to describe reactive UIs</a>. I wonder if they will stick with arrows, or switch to the more familiar monads, as <a href="https://jaspervdj.be/hakyll/">Hakyll</a> did.</p>
<h1 id="day-two"><a href="#day-two" id="day-two-link" class="titlelink" title="day-two">Day Two</a></h1>
<p>The second day keynote was quite ambitious and extremely polished. I recommend reading <a href="http://blog.troutwine.us/2017/02/10/build-good-software/">the companion essay</a>. In short, the keynote was on how technology reflects the politics of the organisations that fund the development, and the importance of creating technology that embeds our desired values. In particular, humans must be kept in the loop and never be totally subservient to machines.</p>
<p>The next talk was by David Turner on <a href="http://www.lambdadays.org/lambdadays2017/david-turner">some history of functional programming</a>. The speaker, the author of Miranda, had been personally involved in many of the efforts that eventually led to Haskell. Turner had some interesting points. For example, that (original) Lisp was not really based on the lambda calculus, as the scope rules were wrong until Scheme introduced static scoping in the 1970s. It was also interesting to hear where various now-popular functional language features had originated. <a href="https://en.wikipedia.org/wiki/ALGOL_60">ALGOL 60</a>, for example, supported functions as parameters, but not return values. The <a href="https://en.wikipedia.org/wiki/ISWIM">ISWIM</a> language, never implemented, supported first-class functions but also had imperative features. A simplified form of ISWIM became FAL, and the functional core of FAL became <a href="https://en.wikipedia.org/wiki/SASL_%28programming_language%29">SASL</a>, the St Andrews Applicative Language. Turner emphasised the removal Lisp’s metaprogramming features (<code>quote</code>/<code>eval</code>), but it is unclear whether SASL was dynamically or statically typed at this point. Initially, SASL was strict and had no real pattern matching, but it eventually became lazy in 1976, and grew pattern guards and <code>case</code>. ISWIM also begat other languages, such as NPL and Hope, where algebraic data types were developed (and copied into SASL). Eventually, a simplified SASL was released as <a href="http://miranda.org.uk/">Miranda</a>, which became the main basis for Haskell. I recommend <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf">this very readable paper</a> for the rest of the Haskell story.</p>
<p>The <a href="http://www.lambdadays.org/lambdadays2017/adam-warski">next talk</a> was on free monads, a frequently mentioned Haskell technique. I do not use free monads in my own code, so maybe I’m missing out. The talk did not really give my any new usage ideas, as it was more about the underlying algebraic inspiration. The <a href="https://www.scala-lang.org/">Scala</a> language was used for exposition, which seemed an awkward choice. The Scala syntax appears almost hostile to idea of functional programming, with much verbose ceremony. And why the awkward name <code>flatMap</code> instead of Haskell’s much clearer <code>&gt;&gt;=</code>?.</p>
<p>I then went to <a href="http://www.lambdadays.org/lambdadays2017/riccardo-terrell">a talk on fast neural networks</a>. I suspect the presenter ran out of time, because he didn’t really get to a main point. He spent some time talking about naive and very inefficient agent-based implementations of neural networks. Are neural networks not best done by bulk array operations these days?</p>
<p>The final talk I was able to attend was a <a href="http://www.lambdadays.org/lambdadays2017/pawel-szulc">very interesting one on recursion schemes</a>. Alas, more Scala. Notation does matter, and Scala syntax is eye poison. My main thought here was whether one could build a language with recursion schemes as a primitive. This could function as an alternative to the flattening algorithm for handling nested parallelism, as the recursive structure could be directly manipulated by the compiler. I definitely agree with the presenter that explicit recursion all too often leads to incomprehensible spaghetti code.</p>

    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
