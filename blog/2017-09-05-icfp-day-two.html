<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ICFP 2017, day 2</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href=".././blog/2017-09-05-icfp-day-two.md">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../blog/" class="thisPage">blog/</a></li><li><a href="../hacks/">hacks/</a></li><li><a href="../links.html">links</a></li><li><a href="../me/">me/</a></li><li><a href="../programs/">programs/</a></li><li><a href="../projects/">projects/</a></li><li><a href="../writings/">writings/</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1>ICFP 2017, day 2</h1>
<div class="postmetadata">
    Posted on September  5, 2017
</div>

<p>The theme of the morning seemed to be verification, and the keynote, <em>Challenges in Assuring AI</em> set the stage quite well. John Launchbury (from Galois) talked about the difficulties involved in verifying that an AI program does what it’s supposed to. It certainly is frustrating that just after the community finally seems to have a handle on how to verify that a program meets some specification (most notably by the construction of verified compilers such as CompCert and CakeML), people start writing programs where it is quite unclear what the specification even <em>is</em>! I was particularly unsettled by his demonstration of the fragility of neural networks, where attackers can make the network dramatically misclassify by adding human-imperceptible noise to the image. I foresee some interesting exploits in the future.</p>
<p>A later talk was <em>Verified Low-Level Programming Embedded in <a href="https://www.fstar-lang.org/">F*</a></em>, which presented a verified implementation of an authentication code (Poly1305). This is in the context of a larger project to write a fully verified HTTPS stack. The idea is to write to separate F* implementations, one that is low-level and using effect types to model the C stack and heap, and one that is high-level and “structurally” correct (or at least safe), then using F* magic to prove that the two implementations are equivalent. From the low-level implementation one can then automatically extract fully verified C code. The performance of the resulting code was fine; matching that of C from OpenSSL, but being significantly outperformed by assembly implementations.</p>
<p>The following talk was <em>Verifying Efficient Function Calls in CakeML</em>. While CompCert (the verified C compiler) gets a lot of attention, CakeML is certainly also worthy of a few raised eyebrows, as it may very well be the first verified compiler for a high-level language. The presentation discusses the verification of a pretty straightforward (and common) optimisation for common-case calls of multi-parameter functions in ML-style languages, where closure allocation is avoided. Interestingly, this is exactly the optimisation that yesterdays presentation found to be buggy in the OCaml compiler!</p>
<p>Perhaps my favourite talk of the day was <em>Better Living through Operational Semantics: An Optimizing Compiler for Radio Protocols</em>. This may because I have a soft spot for the presenter, Geoffrey Mainland, ever since my bachelor’s project, which was an adaptation of his <a href="https://www.cs.drexel.edu/~mainland/projects/flask/">Flask project</a> to run on Arduino devices. Or maybe I just have sympathy for his work, which generally focuses on using high-level languages to program devices that really ought have no business running high-level languages. In this case, he is presenting an optimising compiler for Ziria, which is a language used to implement radio protocols such as the ones used for e.g. WiFi. The focus here was on fusion (apparently radio protocols are basically just stream transducers), and on chunking. The latter is useful for translating e.g. one-bit transducers into a transducer that operates a byte-at-a-time; perhaps even using a lookup table.</p>
<p>The most immediately mind-bending talk was <em>Compiling to Categories</em>. The foundation is that the lambda calculus can be simplified to remove explicit lambdas and names, making it combinator-based instead. It turns out these combinators form a (cartesian closed) category, which provides no end of amusement. The general idea seems to be that we can take “arbitrary” Haskell programs and turn them into compositions within any category that has certain properties. This category could be an executor, a hardware synthesizer, or a graphing tool that produces a visualisation of the program. My bind unbent a bit when I realised this was just yet another deeply embedded language, and that it likely has the same problems as other deep embeddings in Haskell (in particular, recursion becomes awkward). Using (almost) arbitrary categories as the compilation target is a cool trick, though.</p>

    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
