<!DOCTYPE html>
<html lang="en">
  <head>
    <title>index</title>
    <link rel="stylesheet" href="../../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href="../.././programs/arrows/index.lhs">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../../blog/">blog/</a></li><li><a href="../../hacks/">hacks/</a></li><li><a href="../../links.html">links</a></li><li><a href="../../me/">me/</a></li><li><a href="../../programs/" class="thisPage">programs/</a></li><li><a href="../../projects/">projects/</a></li><li><a href="../../writings/">writings/</a></li></ul><ul class="menu1"><li><a href="../../programs/arrows/" class="thisPage">arrows/</a></li><li><a href="../../programs/sigkill.html">sigkill</a></li><li><a href="../../programs/stepping.html">stepping</a></li></ul><ul class="menu2"><li><a href="../../programs/arrows/Circuits.html">Circuits</a></li><li><a href="../../programs/arrows/Sim.html">Sim</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1 id="solutions-to-exercises-in-programming-with-arrows1"><a href="#solutions-to-exercises-in-programming-with-arrows1" id="solutions-to-exercises-in-programming-with-arrows1-link" class="titlelink" title="solutions-to-exercises-in-programming-with-arrows1">Solutions to exercises in <a href="http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</a></a></h1>
<p>Since John Hughes wrote his paper, Arrows have become part of the Haskell standard library. The now-standard version differs incompatibly from the one described in the paper, in that Arrows have to be instances of the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Category.html#t:Category">Category</a> typeclass, so these solutions have been updated to run under the modern, standard definition of Haskell Arrows. The program depends on a similarly updated <code>Sim</code> module, which can be found <a href="Sim.lhs">here</a>. The <a href="Circuits.lhs">updated Circuits module</a> might also be of interest. The code has been written with explicit type signatures for top-level bindings and with an attempt to remove all compiler warnings (although GHC changes so rapidly that it may well complain about something new by the time you read this).</p>
<h2 id="formalia"><a href="#formalia" id="formalia-link" class="titlelink" title="formalia">Formalia</a></h2>
<p>The Arrows language pragma enables the pointed Arrow notation in GHC.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE Arrows #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Control.Category</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Control.Monad.Fix</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="dt">Data.Either</span></a></code></pre></div>
<p>Function composition and the identity operation are both defined more generally in <code>Control.Category</code> than in the Prelude, and we hide the names <code>and</code> and <code>or</code> so we can use them to name circuit components without getting compiler warnings.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id, and, or)</a></code></pre></div>
<p>We prefer the definition of <code>nor</code> from the <code>Sim</code> module. While <code>Circuits.nor</code> works with any Arrow, <code>Sim.nor</code> simulates gate delay, which is useful when we actually need to use <code>nor</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Circuits</span> <span class="kw">hiding</span> (nor)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Sim</span></a></code></pre></div>
<h2 id="the-sf-arrow"><a href="#the-sf-arrow" id="the-sf-arrow-link" class="titlelink" title="the-sf-arrow">The SF arrow</a></h2>
<p>Copied from the paper, apart from factoring part of the Arrow instance out as the Category instance.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">newtype</span> <span class="dt">SF</span> a b <span class="fu">=</span> <span class="dt">SF</span> {<span class="ot"> runSF ::</span> [a] <span class="ot">-&gt;</span> [b] }</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">SF</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="fu">id</span> <span class="fu">=</span> <span class="dt">SF</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="dt">SF</span> f <span class="fu">.</span> <span class="dt">SF</span> g <span class="fu">=</span> <span class="dt">SF</span> (f <span class="fu">.</span> g)</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-8" title="8">  arr f <span class="fu">=</span> <span class="dt">SF</span> (<span class="fu">map</span> f)</a>
<a class="sourceLine" id="cb4-9" title="9">  first (<span class="dt">SF</span> f) <span class="fu">=</span> <span class="dt">SF</span> (<span class="fu">unzip</span> <span class="fu">&gt;&gt;&gt;</span> first f <span class="fu">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">SF</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-12" title="12">  left (<span class="dt">SF</span> f) <span class="fu">=</span> <span class="dt">SF</span> <span class="fu">$</span> \xs <span class="ot">-&gt;</span> combine xs (f <span class="fu">$</span> lefts xs)</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">where</span> combine (<span class="dt">Left</span> _<span class="fu">:</span>xs) (z<span class="fu">:</span>zs) <span class="fu">=</span> <span class="dt">Left</span> z <span class="fu">:</span> combine xs zs</a>
<a class="sourceLine" id="cb4-14" title="14">          combine (<span class="dt">Right</span> y<span class="fu">:</span>xs) zs <span class="fu">=</span> <span class="dt">Right</span> y <span class="fu">:</span> combine xs zs</a>
<a class="sourceLine" id="cb4-15" title="15">          combine [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-16" title="16">          combine _  _ <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;Something impossible happened in ArrowChoice SF&quot;</span></a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="kw">instance</span> <span class="dt">ArrowLoop</span> <span class="dt">SF</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-19" title="19">  loop (<span class="dt">SF</span> f) <span class="fu">=</span> <span class="dt">SF</span> <span class="fu">$</span> \as <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="kw">let</span> (bs,cs) <span class="fu">=</span> <span class="fu">unzip</span> (f (<span class="fu">zip</span> as (stream cs))) <span class="kw">in</span> bs</a>
<a class="sourceLine" id="cb4-21" title="21">      <span class="kw">where</span> stream <span class="fu">~</span>(x<span class="fu">:</span>xs) <span class="fu">=</span> x<span class="fu">:</span>stream xs</a>
<a class="sourceLine" id="cb4-22" title="22"></a>
<a class="sourceLine" id="cb4-23" title="23"><span class="kw">instance</span> <span class="dt">ArrowCircuit</span> <span class="dt">SF</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-24" title="24">  delay x <span class="fu">=</span> <span class="dt">SF</span> (<span class="fu">init</span> <span class="fu">.</span> (x<span class="fu">:</span>))</a></code></pre></div>
<h2 id="exercise-2.5-1"><a href="#exercise-2.5-1" id="exercise-2.5-1-link" class="titlelink" title="exercise-2.5-1">Exercise 2.5-1</a></h2>
<p>See Exercise 3.5-3 below for a prettier version using pointed arrow notation. This implementation is merely a desugared version of that one.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">filterA ::</span> <span class="dt">ArrowChoice</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Bool</span> <span class="ot">-&gt;</span> arr [a] [a]</a>
<a class="sourceLine" id="cb5-2" title="2">filterA p <span class="fu">=</span> arr listcase <span class="fu">&gt;&gt;&gt;</span> <span class="co">-- Check if list is empty.</span></a>
<a class="sourceLine" id="cb5-3" title="3">            (arr (<span class="fu">const</span> []) <span class="fu">|||</span> <span class="co">-- Empty, so stop.</span></a>
<a class="sourceLine" id="cb5-4" title="4">             ((arr <span class="fu">fst</span> <span class="fu">&gt;&gt;&gt;</span> p) <span class="fu">&amp;&amp;&amp;</span> <span class="fu">id</span> <span class="co">-- Check if head of list fulfills predicate.</span></a>
<a class="sourceLine" id="cb5-5" title="5">              <span class="fu">&gt;&gt;&gt;</span> arr check <span class="co">-- Convert tuple with bool to Left/Right.</span></a>
<a class="sourceLine" id="cb5-6" title="6">              <span class="fu">&gt;&gt;&gt;</span> ((arr <span class="fu">snd</span> <span class="fu">&gt;&gt;&gt;</span> filterA p) <span class="fu">|||</span> <span class="co">-- Discard head.</span></a>
<a class="sourceLine" id="cb5-7" title="7">                   (arr <span class="fu">id</span> <span class="fu">***</span> filterA p <span class="fu">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="fu">:</span>)))))) <span class="co">-- Keep head.</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="kw">where</span> listcase [] <span class="fu">=</span> <span class="dt">Left</span> ()</a>
<a class="sourceLine" id="cb5-9" title="9">        listcase (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Right</span> (x,xs)</a>
<a class="sourceLine" id="cb5-10" title="10">        check (<span class="dt">False</span>, v) <span class="fu">=</span> <span class="dt">Left</span> v</a>
<a class="sourceLine" id="cb5-11" title="11">        check (<span class="dt">True</span>, v)  <span class="fu">=</span> <span class="dt">Right</span> v</a></code></pre></div>
<h2 id="exercise-2.5-2"><a href="#exercise-2.5-2" id="exercise-2.5-2-link" class="titlelink" title="exercise-2.5-2">Exercise 2.5-2</a></h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">SP</span> a b <span class="fu">=</span> <span class="dt">Put</span> b (<span class="dt">SP</span> a b) <span class="fu">|</span> <span class="dt">Get</span> (a <span class="ot">-&gt;</span> <span class="dt">SP</span> a b)</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ot">runSP ::</span> <span class="dt">SP</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb6-4" title="4">runSP (<span class="dt">Put</span> b s) as <span class="fu">=</span> b<span class="fu">:</span>runSP s as</a>
<a class="sourceLine" id="cb6-5" title="5">runSP (<span class="dt">Get</span> k) (a<span class="fu">:</span>as) <span class="fu">=</span> runSP (k a) as</a>
<a class="sourceLine" id="cb6-6" title="6">runSP (<span class="dt">Get</span> _) [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">SP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">$</span> <span class="fu">flip</span> <span class="dt">Put</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="dt">Put</span> v f <span class="fu">.</span> g <span class="fu">=</span> <span class="dt">Put</span> v (f <span class="fu">.</span> g)</a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="dt">Get</span> f <span class="fu">.</span> <span class="dt">Put</span> v g <span class="fu">=</span> f v <span class="fu">.</span> g</a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="dt">Get</span> f <span class="fu">.</span> <span class="dt">Get</span> g <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Get</span> f <span class="fu">.</span> g x</a></code></pre></div>
<p>Defining first presents a problem, as consuming one element of input does not necessarily produce exactly one element of output. The synchronisation function I have implemented opts to never throw away and never duplicate data, but that implies that the lists of “delayed” I/O may grow with no upper bound. It is not hard to modify the function to follow some other strategy with constant upper bounds on buffering requirements. And of course, the use of lists here is highly inefficient, a proper deque (Data.Sequence, for example) should be used.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2">  arr f <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Put</span> (f x) (arr f)</a>
<a class="sourceLine" id="cb7-3" title="3">  first f <span class="fu">=</span> sync f [] []</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="ot">sync ::</span> <span class="dt">SP</span> a c <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">SP</span> (a, b) (c, b)</a>
<a class="sourceLine" id="cb7-6" title="6">sync (<span class="dt">Put</span> v f) xs (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="dt">Put</span> (v,y) (sync f xs ys)</a>
<a class="sourceLine" id="cb7-7" title="7">sync (<span class="dt">Put</span> v f) xs []     <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">$</span> \(x,y) <span class="ot">-&gt;</span> <span class="dt">Put</span> (v,y) (sync f (xs<span class="fu">++</span>[x]) [])</a>
<a class="sourceLine" id="cb7-8" title="8">sync (<span class="dt">Get</span> f)   (x<span class="fu">:</span>xs) ys <span class="fu">=</span> sync (f x) xs ys</a>
<a class="sourceLine" id="cb7-9" title="9">sync (<span class="dt">Get</span> f)   [] ys     <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">$</span> \(x,y) <span class="ot">-&gt;</span> sync (f x) [] (ys<span class="fu">++</span>[y])</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">SP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-12" title="12">  left (<span class="dt">Put</span> v f) <span class="fu">=</span> <span class="dt">Put</span> (<span class="dt">Left</span> v) (left f)</a>
<a class="sourceLine" id="cb7-13" title="13">  left (<span class="dt">Get</span> f) <span class="fu">=</span> <span class="dt">Get</span> g</a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="kw">where</span> g (<span class="dt">Left</span> x)  <span class="fu">=</span> left <span class="fu">$</span> f x</a>
<a class="sourceLine" id="cb7-15" title="15">          g (<span class="dt">Right</span> x) <span class="fu">=</span> <span class="dt">Put</span> (<span class="dt">Right</span> x) (left <span class="fu">$</span> <span class="dt">Get</span> f)</a></code></pre></div>
<p>We traverse down the stream function to look for an ‘initial’ state, then run the function with that state. This depends critically on lazy evaluation.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">instance</span> <span class="dt">ArrowLoop</span> <span class="dt">SP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2">  loop f <span class="fu">=</span> <span class="kw">let</span> (f',s) <span class="fu">=</span> next f s <span class="kw">in</span> f'</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">where</span> next (<span class="dt">Put</span> (v,s) f') _ <span class="fu">=</span> (<span class="dt">Put</span> v (<span class="fu">fst</span> <span class="fu">$</span> next f' s), s)</a>
<a class="sourceLine" id="cb8-4" title="4">          next (<span class="dt">Get</span> f')       s <span class="fu">=</span> (<span class="dt">Get</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">let</span> (f'',s') <span class="fu">=</span> next (f' (x,s')) s</a>
<a class="sourceLine" id="cb8-5" title="5">                                               <span class="kw">in</span> f'', s)</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">instance</span> <span class="dt">ArrowCircuit</span> <span class="dt">SP</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" title="8">  delay v <span class="fu">=</span> <span class="dt">Put</span> v <span class="fu">id</span></a></code></pre></div>
<h2 id="exercise-3.5-1"><a href="#exercise-3.5-1" id="exercise-3.5-1-link" class="titlelink" title="exercise-3.5-1">Exercise 3.5-1</a></h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">halfAdd ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr (<span class="dt">Bool</span>,<span class="dt">Bool</span>) (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb9-2" title="2">halfAdd <span class="fu">=</span> arr <span class="fu">$</span> \(x,y) <span class="ot">-&gt;</span> (x<span class="fu">&amp;&amp;</span>y, x<span class="fu">/=</span>y)</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">fullAdd ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr (<span class="dt">Bool</span>, <span class="dt">Bool</span>, <span class="dt">Bool</span>) (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb9-5" title="5">fullAdd <span class="fu">=</span> proc (x,y,c) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-6" title="6">            (c1,s1) <span class="ot">&lt;-</span> halfAdd <span class="fu">-&lt;</span> (x,y)</a>
<a class="sourceLine" id="cb9-7" title="7">            (c2,s2) <span class="ot">&lt;-</span> halfAdd <span class="fu">-&lt;</span> (s1, c)</a>
<a class="sourceLine" id="cb9-8" title="8">            returnA <span class="fu">-&lt;</span> (c1<span class="fu">||</span>c2,s2)</a></code></pre></div>
<p>It is instructive to see the desugared version:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">fullAddNoSugar ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr (<span class="dt">Bool</span>, <span class="dt">Bool</span>, <span class="dt">Bool</span>) (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">fullAddNoSugar <span class="fu">=</span> arr (\(x,y,c) <span class="ot">-&gt;</span> ((x,y), c))</a>
<a class="sourceLine" id="cb10-3" title="3">                 <span class="fu">&gt;&gt;&gt;</span> first halfAdd</a>
<a class="sourceLine" id="cb10-4" title="4">                 <span class="fu">&gt;&gt;&gt;</span> arr (\((c1,s1),c) <span class="ot">-&gt;</span> ((s1,c), c1))</a>
<a class="sourceLine" id="cb10-5" title="5">                 <span class="fu">&gt;&gt;&gt;</span> first halfAdd</a>
<a class="sourceLine" id="cb10-6" title="6">                 <span class="fu">&gt;&gt;&gt;</span> arr (\((c2,s2),c1) <span class="ot">-&gt;</span> (c1<span class="fu">||</span>c2,s2))</a></code></pre></div>
<p>The <em>n</em>-bit adder takes an argument, <code>m</code>, which is the number of bits in the inputs, and the adder will fail if the input lists are not each of length <code>m</code>. The helper function <code>more</code> constructs the <code>m</code> adders, connecting the carry-out of one to the carry-in of the next. The carry-in of the first adder is always wired to <code>False</code>, and the carry-out of the last one is passed out of the entire adder.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">adder ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> arr ([<span class="dt">Bool</span>], [<span class="dt">Bool</span>]) ([<span class="dt">Bool</span>],<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-2" title="2">adder m <span class="fu">=</span> proc (x, y) <span class="ot">-&gt;</span> more m <span class="fu">-&lt;</span> (x,y,<span class="dt">False</span>)</a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">where</span> more <span class="dv">0</span> <span class="fu">=</span> proc (_,_,cout) <span class="ot">-&gt;</span> returnA <span class="fu">-&lt;</span> ([],cout)</a>
<a class="sourceLine" id="cb11-4" title="4">        more n <span class="fu">=</span> proc (x'<span class="fu">:</span>xs,y'<span class="fu">:</span>ys,cin) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-5" title="5">          (carry,b) <span class="ot">&lt;-</span> fullAdd <span class="fu">-&lt;</span> (x',y',cin)</a>
<a class="sourceLine" id="cb11-6" title="6">          (z,cout) <span class="ot">&lt;-</span> more (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">-&lt;</span> (xs,ys,carry)</a>
<a class="sourceLine" id="cb11-7" title="7">          returnA <span class="fu">-&lt;</span> (b<span class="fu">:</span>z, cout)</a></code></pre></div>
<h2 id="exercise-3.5-2"><a href="#exercise-3.5-2" id="exercise-3.5-2-link" class="titlelink" title="exercise-3.5-2">Exercise 3.5-2</a></h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">bsadd ::</span> <span class="dt">ArrowCircuit</span> arr <span class="ot">=&gt;</span> arr (<span class="dt">Bool</span>,<span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" title="2">bsadd <span class="fu">=</span> proc (x,y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" title="3">          rec (cout,b) <span class="ot">&lt;-</span> fullAdd <span class="fu">-&lt;</span> (x,y,cin)</a>
<a class="sourceLine" id="cb12-4" title="4">              cin      <span class="ot">&lt;-</span> delay <span class="dt">False</span> <span class="fu">-&lt;</span> cout</a>
<a class="sourceLine" id="cb12-5" title="5">          returnA <span class="fu">-&lt;</span> b</a></code></pre></div>
<h2 id="exercise-3.5-3"><a href="#exercise-3.5-3" id="exercise-3.5-3-link" class="titlelink" title="exercise-3.5-3">Exercise 3.5-3</a></h2>
<h2 id="a"><a href="#a" id="a-link" class="titlelink" title="a">(a)</a></h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">filterA' ::</span> <span class="dt">ArrowChoice</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Bool</span> <span class="ot">-&gt;</span> arr [a] [a]</a>
<a class="sourceLine" id="cb13-2" title="2">filterA' p <span class="fu">=</span> proc xs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-4" title="4">    [] <span class="ot">-&gt;</span> returnA <span class="fu">-&lt;</span> []</a>
<a class="sourceLine" id="cb13-5" title="5">    x<span class="fu">:</span>xs' <span class="ot">-&gt;</span> <span class="kw">do</span> c <span class="ot">&lt;-</span> p <span class="fu">-&lt;</span> x</a>
<a class="sourceLine" id="cb13-6" title="6">                l <span class="ot">&lt;-</span> filterA' p <span class="fu">-&lt;</span> xs'</a>
<a class="sourceLine" id="cb13-7" title="7">                <span class="kw">if</span> c <span class="kw">then</span> arr (<span class="fu">uncurry</span> (<span class="fu">:</span>)) <span class="fu">-&lt;</span> (x,l)</a>
<a class="sourceLine" id="cb13-8" title="8">                     <span class="kw">else</span> returnA <span class="fu">-&lt;</span> l</a></code></pre></div>
<h2 id="b"><a href="#b" id="b-link" class="titlelink" title="b">(b)</a></h2>
<p>I admit that I do not yet have much intuition for command combinators.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">filterC ::</span> <span class="dt">ArrowChoice</span> arr <span class="ot">=&gt;</span> arr (env,a) <span class="dt">Bool</span> <span class="ot">-&gt;</span> arr (env,[a]) [a]</a>
<a class="sourceLine" id="cb14-2" title="2">filterC p <span class="fu">=</span> proc (env, xs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-4" title="4">    [] <span class="ot">-&gt;</span> returnA <span class="fu">-&lt;</span> []</a>
<a class="sourceLine" id="cb14-5" title="5">    x<span class="fu">:</span>xs' <span class="ot">-&gt;</span> <span class="kw">do</span> c <span class="ot">&lt;-</span> p <span class="fu">-&lt;</span> (env,x)</a>
<a class="sourceLine" id="cb14-6" title="6">                l <span class="ot">&lt;-</span> filterC p <span class="fu">-&lt;</span> (env,xs')</a>
<a class="sourceLine" id="cb14-7" title="7">                <span class="kw">if</span> c <span class="kw">then</span> arr (<span class="fu">uncurry</span> (<span class="fu">:</span>)) <span class="fu">-&lt;</span> (x,l)</a>
<a class="sourceLine" id="cb14-8" title="8">                     <span class="kw">else</span> returnA <span class="fu">-&lt;</span> l</a></code></pre></div>
<h2 id="exercise-3.5-4"><a href="#exercise-3.5-4" id="exercise-3.5-4-link" class="titlelink" title="exercise-3.5-4">Exercise 3.5-4</a></h2>
<h2 id="a-1"><a href="#a-1" id="a-1-link" class="titlelink" title="a-1">(a)</a></h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">rowC ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb15-2" title="2">        <span class="dt">Int</span> <span class="ot">-&gt;</span> arr (env,(a,b)) (c,a) <span class="ot">-&gt;</span> arr (env,(a,[b])) ([c],a)</a>
<a class="sourceLine" id="cb15-3" title="3">rowC <span class="dv">0</span> _ <span class="fu">=</span> proc (_,(a,[])) <span class="ot">-&gt;</span> returnA <span class="fu">-&lt;</span> ([],a)</a>
<a class="sourceLine" id="cb15-4" title="4">rowC n f <span class="fu">=</span> proc (env,(a,b<span class="fu">:</span>bs)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-5" title="5">             (c,a') <span class="ot">&lt;-</span> f <span class="fu">-&lt;</span> (env,(a,b))</a>
<a class="sourceLine" id="cb15-6" title="6">             (cs,a'') <span class="ot">&lt;-</span> rowC (n<span class="fu">-</span><span class="dv">1</span>) f <span class="fu">-&lt;</span> (env, (a',bs))</a>
<a class="sourceLine" id="cb15-7" title="7">             returnA <span class="fu">-&lt;</span> (c<span class="fu">:</span>cs,a'')</a></code></pre></div>
<h2 id="b-1"><a href="#b-1" id="b-1-link" class="titlelink" title="b-1">(b)</a></h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">counter1bit ::</span> <span class="dt">ArrowCircuit</span> arr <span class="ot">=&gt;</span> arr <span class="dt">Bool</span> (<span class="dt">Bool</span>,<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb16-2" title="2">counter1bit <span class="fu">=</span> proc b <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" title="3">                rec sumin <span class="ot">&lt;-</span> delay <span class="dt">False</span> <span class="fu">-&lt;</span> <span class="fu">sum</span></a>
<a class="sourceLine" id="cb16-4" title="4">                    (carry,<span class="fu">sum</span>) <span class="ot">&lt;-</span> halfAdd <span class="fu">-&lt;</span> (sumin,b)</a>
<a class="sourceLine" id="cb16-5" title="5">                returnA <span class="fu">-&lt;</span> (<span class="fu">sum</span>, carry)</a></code></pre></div>
<h2 id="c"><a href="#c" id="c-link" class="titlelink" title="c">(c)</a></h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">counternbit ::</span> <span class="dt">ArrowCircuit</span> arr <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> arr <span class="dt">Bool</span> ([<span class="dt">Bool</span>],<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb17-2" title="2">counternbit n <span class="fu">=</span> proc bs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-3" title="3">  (<span class="fu">|</span>(rowC n) (\(b,_) <span class="ot">-&gt;</span> counter1bit <span class="fu">-&lt;</span> b)<span class="fu">|</span>) (bs, [<span class="dv">0</span><span class="fu">..</span>n<span class="fu">-</span><span class="dv">1</span>])</a></code></pre></div>
<h2 id="d"><a href="#d" id="d-link" class="titlelink" title="d">(d)</a></h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">counter1bit' ::</span> <span class="dt">ArrowCircuit</span> arr <span class="ot">=&gt;</span> arr (<span class="dt">Bool</span>,<span class="dt">Bool</span>) (<span class="dt">Bool</span>,<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-2" title="2">counter1bit' <span class="fu">=</span> proc (b,rst) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-3" title="3">                 rec sumin <span class="ot">&lt;-</span> delay <span class="dt">False</span> <span class="fu">-&lt;</span> <span class="fu">sum</span></a>
<a class="sourceLine" id="cb18-4" title="4">                     (carry,<span class="fu">sum</span>) <span class="ot">&lt;-</span> halfAdd <span class="fu">-&lt;</span> (<span class="fu">not</span> rst <span class="fu">&amp;&amp;</span> sumin,<span class="fu">not</span> rst <span class="fu">&amp;&amp;</span> b)</a>
<a class="sourceLine" id="cb18-5" title="5">                 returnA <span class="fu">-&lt;</span> (<span class="fu">sum</span>, carry)</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="ot">counternbit' ::</span> <span class="dt">ArrowCircuit</span> arr <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> arr (<span class="dt">Bool</span>,<span class="dt">Bool</span>) ([<span class="dt">Bool</span>],<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-8" title="8">counternbit' n <span class="fu">=</span> proc (bs,rsts) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-9" title="9">  (<span class="fu">|</span>(rowC n) (\(b,rst) <span class="ot">-&gt;</span> counter1bit' <span class="fu">-&lt;</span> (b,rst))<span class="fu">|</span>) (bs, <span class="fu">replicate</span> n rsts)</a></code></pre></div>
<h2 id="exercise-5.6-1"><a href="#exercise-5.6-1" id="exercise-5.6-1-link" class="titlelink" title="exercise-5.6-1">Exercise 5.6-1</a></h2>
<p>Note that since Sim is an Arrow, the trivial solution to this exercise is to simple reuse the previous definitions. Instead, I will define “realistic” circuits using NOR logic. Since the <code>nor</code> gate simulates gate delay, this means all derived gates will also have proper delays.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="fu">and</span> <span class="fu">=</span> proc (a,b) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" title="3">        a' <span class="ot">&lt;-</span> nor <span class="fu">-&lt;</span> (a,a)</a>
<a class="sourceLine" id="cb19-4" title="4">        b' <span class="ot">&lt;-</span> nor <span class="fu">-&lt;</span> (b,b)</a>
<a class="sourceLine" id="cb19-5" title="5">        nubA <span class="fu">&lt;&lt;&lt;</span> nor <span class="fu">-&lt;</span> (a',b')</a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="fu">or</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="fu">or</span> <span class="fu">=</span> proc (a,b) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-9" title="9">        a' <span class="ot">&lt;-</span> nor <span class="fu">-&lt;</span> (a,b)</a>
<a class="sourceLine" id="cb19-10" title="10">        b' <span class="ot">&lt;-</span> nor <span class="fu">-&lt;</span> (a,b)</a>
<a class="sourceLine" id="cb19-11" title="11">        nubA <span class="fu">&lt;&lt;&lt;</span> nor <span class="fu">-&lt;</span> (a',b')</a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13"><span class="ot">lnot ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m <span class="dt">Bool</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-14" title="14">lnot <span class="fu">=</span> nubA <span class="fu">&lt;&lt;&lt;</span> nor <span class="fu">&lt;&lt;&lt;</span> <span class="fu">id</span> <span class="fu">&amp;&amp;&amp;</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb19-15" title="15"></a>
<a class="sourceLine" id="cb19-16" title="16"><span class="ot">xor ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>, <span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-17" title="17">xor <span class="fu">=</span> proc (a,b) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-18" title="18">        c <span class="ot">&lt;-</span> <span class="fu">and</span> <span class="fu">-&lt;</span> (a,b)</a>
<a class="sourceLine" id="cb19-19" title="19">        d <span class="ot">&lt;-</span> nor <span class="fu">-&lt;</span> (a,b)</a>
<a class="sourceLine" id="cb19-20" title="20">        nubA <span class="fu">&lt;&lt;&lt;</span> nor <span class="fu">-&lt;</span> (c,d)</a>
<a class="sourceLine" id="cb19-21" title="21"></a>
<a class="sourceLine" id="cb19-22" title="22"><span class="ot">halfAddSim ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>) (<span class="dt">Bool</span>,<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb19-23" title="23">halfAddSim <span class="fu">=</span> proc (x,y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-24" title="24">             c <span class="ot">&lt;-</span> <span class="fu">and</span> <span class="fu">-&lt;</span> (x,y)</a>
<a class="sourceLine" id="cb19-25" title="25">             s <span class="ot">&lt;-</span> xor <span class="fu">-&lt;</span> (x,y)</a>
<a class="sourceLine" id="cb19-26" title="26">             nubA <span class="fu">-&lt;</span> (c,s)</a></code></pre></div>
<p>From here on, the definitions are mostly trivial substitutions of the previous ones, as they are all ultimately built on top of half-adders. In fact, rowC is not changed at all. nubA has been used to remove glitches. Note that the circuits are now highly sensitive to timing issues and should be extended with a clock input to be useful for anything.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">fullAdd' ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>,<span class="dt">Bool</span>) (<span class="dt">Bool</span>,<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb20-2" title="2">fullAdd' <span class="fu">=</span> proc (x,y,c) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-3" title="3">             (c1,s1) <span class="ot">&lt;-</span> halfAddSim <span class="fu">-&lt;</span> (x,y)</a>
<a class="sourceLine" id="cb20-4" title="4">             (c2,s2) <span class="ot">&lt;-</span> halfAddSim <span class="fu">-&lt;</span> (s1,c)</a>
<a class="sourceLine" id="cb20-5" title="5">             c'      <span class="ot">&lt;-</span> <span class="fu">or</span> <span class="fu">-&lt;</span> (c1,c2)</a>
<a class="sourceLine" id="cb20-6" title="6">             nubA <span class="fu">-&lt;</span> (c',s2)</a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="ot">bsadd' ::</span> <span class="dt">MonadFix</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-9" title="9">bsadd' <span class="fu">=</span> proc (x,y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-10" title="10">           (b,_) <span class="ot">&lt;-</span> (<span class="fu">|</span>afix (\ <span class="fu">~</span>(_,cin) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-11" title="11">                              cin' <span class="ot">&lt;-</span> initially <span class="dt">False</span> nubA <span class="fu">-&lt;</span> cin</a>
<a class="sourceLine" id="cb20-12" title="12">                              (cout,b) <span class="ot">&lt;-</span> fullAdd' <span class="fu">-&lt;</span> (x,y,cin')</a>
<a class="sourceLine" id="cb20-13" title="13">                              returnA <span class="fu">-&lt;</span> (b,cout))<span class="fu">|</span>)</a>
<a class="sourceLine" id="cb20-14" title="14">           returnA <span class="fu">-&lt;</span> b</a>
<a class="sourceLine" id="cb20-15" title="15"></a>
<a class="sourceLine" id="cb20-16" title="16"><span class="ot">counter1bit'' ::</span> <span class="dt">Sim</span> <span class="dt">IO</span> (<span class="dt">Bool</span>,<span class="dt">Bool</span>) (<span class="dt">Bool</span>,<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb20-17" title="17">counter1bit'' <span class="fu">=</span> proc (b,rst) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-18" title="18">                (<span class="fu">|</span>afix (\ <span class="fu">~</span>(sumin,_) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-19" title="19">                          sumin' <span class="ot">&lt;-</span> initially <span class="dt">False</span> nubA <span class="fu">-&lt;</span> sumin</a>
<a class="sourceLine" id="cb20-20" title="20">                          x <span class="ot">&lt;-</span> <span class="fu">and</span> <span class="fu">&lt;&lt;&lt;</span> first lnot <span class="fu">&lt;&lt;&lt;</span> delay1 <span class="fl">0.2</span> <span class="fu">-&lt;</span> (rst,sumin')</a>
<a class="sourceLine" id="cb20-21" title="21">                          y <span class="ot">&lt;-</span> <span class="fu">and</span> <span class="fu">&lt;&lt;&lt;</span> first lnot <span class="fu">&lt;&lt;&lt;</span> nubA <span class="fu">-&lt;</span> (rst,b)</a>
<a class="sourceLine" id="cb20-22" title="22">                          (c,s) <span class="ot">&lt;-</span> halfAddSim <span class="fu">-&lt;</span> (x,y)</a>
<a class="sourceLine" id="cb20-23" title="23">                          returnA <span class="fu">-&lt;</span> (s,c))<span class="fu">|</span>)</a>
<a class="sourceLine" id="cb20-24" title="24"></a>
<a class="sourceLine" id="cb20-25" title="25"><span class="ot">counternbit'' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sim</span> <span class="dt">IO</span> (<span class="dt">Bool</span>,<span class="dt">Bool</span>) ([<span class="dt">Bool</span>],<span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb20-26" title="26">counternbit'' n <span class="fu">=</span> proc (bs,rsts) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-27" title="27">  (<span class="fu">|</span>(rowC n) (\(b,rst) <span class="ot">-&gt;</span> counter1bit'' <span class="fu">-&lt;</span> (b,rst))<span class="fu">|</span>) (bs, <span class="fu">replicate</span> n rsts)</a></code></pre></div>
<p>Note that the following is an orphan instance, since it is defined outside the modules where Sim or ArrowChoice is defined.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> (<span class="dt">Sim</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" title="2">  left (<span class="dt">Sim</span> f) <span class="fu">=</span> sim left'</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">where</span> left' (<span class="dt">Left</span> b) <span class="fu">=</span> <span class="kw">do</span> (c,s) <span class="ot">&lt;-</span> f b</a>
<a class="sourceLine" id="cb21-4" title="4">                              <span class="fu">return</span> (<span class="dt">Left</span> c,leftState b s)</a>
<a class="sourceLine" id="cb21-5" title="5">          left' (<span class="dt">Right</span> d) <span class="fu">=</span> <span class="fu">return</span> (<span class="dt">Right</span> d, untilLeft f)</a>
<a class="sourceLine" id="cb21-6" title="6"></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="ot">untilLeft ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (c, <span class="dt">State</span> m b c))</a>
<a class="sourceLine" id="cb21-8" title="8">          <span class="ot">-&gt;</span> (<span class="dt">State</span> m (<span class="dt">Either</span> b d) (<span class="dt">Either</span> c d))</a>
<a class="sourceLine" id="cb21-9" title="9">untilLeft f <span class="fu">=</span> <span class="dt">Wait</span> infinity <span class="fu">undefined</span> <span class="fu">$</span> \e <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-10" title="10">              <span class="kw">case</span> value e <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-11" title="11">                <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="dt">Ready</span> (<span class="dt">Event</span> (time e) (<span class="dt">Right</span> d)) (untilLeft f)</a>
<a class="sourceLine" id="cb21-12" title="12">                <span class="dt">Left</span>  b <span class="ot">-&gt;</span> <span class="dt">Lift</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-13" title="13">                             (c,s) <span class="ot">&lt;-</span> f b</a>
<a class="sourceLine" id="cb21-14" title="14">                             <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Ready</span> (<span class="dt">Event</span> (time e) (<span class="dt">Left</span> c)) (leftState b s)</a>
<a class="sourceLine" id="cb21-15" title="15"></a>
<a class="sourceLine" id="cb21-16" title="16"><span class="ot">leftState ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">State</span> m b c <span class="ot">-&gt;</span> <span class="dt">State</span> m (<span class="dt">Either</span> b d) (<span class="dt">Either</span> c d)</a>
<a class="sourceLine" id="cb21-17" title="17">leftState b (<span class="dt">Ready</span> e s) <span class="fu">=</span> <span class="dt">Ready</span> (e {value <span class="fu">=</span> <span class="dt">Left</span> (value e)}) (leftState b s)</a>
<a class="sourceLine" id="cb21-18" title="18">leftState b (<span class="dt">Lift</span> m) <span class="fu">=</span> <span class="dt">Lift</span> (liftM (leftState b) m)</a>
<a class="sourceLine" id="cb21-19" title="19">leftState b (<span class="dt">Wait</span> t s k) <span class="fu">=</span> <span class="dt">Wait</span> t (leftState b s) <span class="fu">$</span> \e <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-20" title="20">                           <span class="kw">case</span> value e <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-21" title="21">                             <span class="dt">Left</span> b' <span class="ot">-&gt;</span> leftState b' <span class="fu">$</span> k e { value <span class="fu">=</span> b' }</a>
<a class="sourceLine" id="cb21-22" title="22">                             <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="dt">Ready</span> (<span class="dt">Event</span> (time e) (<span class="dt">Right</span> d))</a>
<a class="sourceLine" id="cb21-23" title="23">                                        (leftState b <span class="fu">$</span> k e { value <span class="fu">=</span> b })</a>
<a class="sourceLine" id="cb21-24" title="24"></a>
<a class="sourceLine" id="cb21-25" title="25"><span class="ot">maybeneg ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sim</span> m (<span class="dt">Bool</span>,<span class="dt">Bool</span>) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-26" title="26">maybeneg <span class="fu">=</span> proc (x,neg) <span class="ot">-&gt;</span> <span class="kw">if</span> neg <span class="kw">then</span> returnA <span class="fu">-&lt;</span> <span class="fu">not</span> x</a>
<a class="sourceLine" id="cb21-27" title="27">                           <span class="kw">else</span> returnA <span class="fu">-&lt;</span> x</a></code></pre></div>
    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
