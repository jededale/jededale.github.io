<!DOCTYPE html>
<html lang="en">
  <head>
    <title>stepping</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href=".././programs/stepping.lhs">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../blog/">blog/</a></li><li><a href="../hacks/">hacks/</a></li><li><a href="../links.html">links</a></li><li><a href="../me/">me/</a></li><li><a href="../programs/" class="thisPage">programs/</a></li><li><a href="../projects/">projects/</a></li><li><a href="../writings/">writings/</a></li></ul><ul class="menu1"><li><a href="../programs/arrows/">arrows/</a></li><li><a href="../programs/sigkill.html">sigkill</a></li><li><a href="../programs/stepping.html" class="thisPage">stepping</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1 id="writing-a-single-stepping-interpreter-with-monads"><a href="#writing-a-single-stepping-interpreter-with-monads" id="writing-a-single-stepping-interpreter-with-monads-link" class="titlelink" title="writing-a-single-stepping-interpreter-with-monads">Writing a Single-Stepping Interpreter with Monads</a></h1>
<p>One nice thing about Haskell monads - perhaps the nicest - is how they permit separation of concerns. You can write code in a straightforward way, without knowing that underneath it all, all kinds of implicit control flow may be happening. Usually, when we use monads in Haskell, we use the standard ones: <code>Maybe</code>, <code>Either</code>, lists, and so on. When we design our programs, use tend to use compositions of <code>Reader</code>, <code>Writer</code>, <code>State</code>, and probably <code>IO</code> somewhere. This is fine. Going overboard with odd monadic effects is probably not good for readability. But, sometimes it is important to remember that defining your own idiosyncratic monad can allow an elegant implementation of something seemingly very complicated. In this Literate Haskell program, we will see how to implement an single-stepping interpreter for a very simple Lisp dialect, structured in a monadic style. In fact, the single-stepping support is going to be a minuscule part of the overall code. Please note that when we write “Lisp”, we mean a highly cut-down and simplified language that bears only a superficial resemblance to modern industrial Lisp dialects.</p>
<p>This is not a monad tutorial. This program will not be comprehensible unless you already know how to work with monads in Haskell. All I am trying to do is demonstrate a technique that I find cool.</p>
<p>First, we need the usual module boilerplate. Three of the four imports are for the small command line interface we will add near the end.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Control.Monad</span> (ap, liftM)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Data.Char</span> (isSpace, isDigit)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Text.ParserCombinators.ReadP</span></a></code></pre></div>
<h2 id="s-expressions"><a href="#s-expressions" id="s-expressions-link" class="titlelink" title="s-expressions">S-Expressions</a></h2>
<p>In Lisp, the same structure is used for representing both code and data values: the so-called <em>S-expression</em>. An S-expression is either an <em>atom</em> or a <em>cons cell</em> (or just <em>cons</em>). A cons is just a pair of two other values, called <code>car</code> and <code>cdr</code> for ancient and arcane reasons. An atom is either a symbol or a number. We encapsulate this as one data type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">SExp</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">SExp</span> <span class="dt">SExp</span> <span class="fu">|</span> <span class="dt">Symbol</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Int</span></a></code></pre></div>
<p>We print a cons as <code>(a . b)</code>, where <code>a</code> and <code>b</code> are its constituents. There are two special cases:</p>
<ul>
<li><p>if <code>b</code> is itself a cons <code>(c . d)</code>, we print <code>(a c . d)</code>, and recursively.</p></li>
<li><p>if <code>b</code> is the symbol <code>nil</code>, then we print simply <code>(a)</code>.</p></li>
</ul>
<p>By convention, the empty list is represented as the symbol <code>nil</code>. These conventions let us print the common case of a linked list as <code>(a b c)</code> instead of <code>(a . (b . (c . nil)))</code>. We implement the printing as an instance of the <code>Show</code> typeclass - I am not normally a fan of using this for human-readable information, but I do not wish to include a prettyprinting library for this program.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">SExp</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2"> <span class="fu">show</span> (<span class="dt">Symbol</span> s) <span class="fu">=</span> s</a>
<a class="sourceLine" id="cb3-3" title="3"> <span class="fu">show</span> (<span class="dt">Number</span> x) <span class="fu">=</span> <span class="fu">show</span> x</a>
<a class="sourceLine" id="cb3-4" title="4"> <span class="fu">show</span> (<span class="dt">Cons</span> a b) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> <span class="fu">show</span> a <span class="fu">++</span> recurse b <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb3-5" title="5">   <span class="kw">where</span> recurse (<span class="dt">Symbol</span> <span class="st">&quot;nil&quot;</span>)          <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb3-6" title="6">         recurse (<span class="dt">Cons</span> c d)              <span class="fu">=</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> <span class="fu">show</span> c <span class="fu">++</span> recurse d</a>
<a class="sourceLine" id="cb3-7" title="7">         recurse x                       <span class="fu">=</span> <span class="st">&quot; . &quot;</span> <span class="fu">++</span> <span class="fu">show</span> x</a></code></pre></div>
<p>We can turn any Haskell list of S-expressions into an S-expression that represents that same list, using the <code>car</code>s to contain the head, and the <code>cdr</code> the link to the tail of the list. We use the symbol <code>nil</code> to represent the empty list.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">toSExp ::</span> [<span class="dt">SExp</span>] <span class="ot">-&gt;</span> <span class="dt">SExp</span></a>
<a class="sourceLine" id="cb4-2" title="2">toSExp []     <span class="fu">=</span> <span class="dt">Symbol</span> <span class="st">&quot;nil&quot;</span></a>
<a class="sourceLine" id="cb4-3" title="3">toSExp (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Cons</span> x (toSExp xs)</a></code></pre></div>
<p>We can also try to convert a SExp to a Haskell list of SExps, although this is not guaranteed to work.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">fromSExp ::</span> <span class="dt">SExp</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">SExp</span>]</a>
<a class="sourceLine" id="cb5-2" title="2">fromSExp (<span class="dt">Symbol</span> <span class="st">&quot;nil&quot;</span>) <span class="fu">=</span> <span class="dt">Just</span> []</a>
<a class="sourceLine" id="cb5-3" title="3">fromSExp (<span class="dt">Cons</span> car cdr) <span class="fu">=</span> <span class="kw">do</span> cdr' <span class="ot">&lt;-</span> fromSExp cdr</a>
<a class="sourceLine" id="cb5-4" title="4">                             <span class="dt">Just</span> <span class="fu">$</span> car <span class="fu">:</span> cdr'</a>
<a class="sourceLine" id="cb5-5" title="5">fromSExp _              <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<h2 id="the-monad"><a href="#the-monad" id="the-monad-link" class="titlelink" title="the-monad">The Monad</a></h2>
<p>Before we write the evaluation functions, we’ll define the <code>InterpM</code> monad we will be using. Computation can be in three different states: either we have a value (<code>Result</code>), we have encountered an error during evaluation (<code>Error</code>), or we are at a <em>stepping point</em> (<code>Step</code>). This is a labeled breakpoint in execution where we have the option of continuing execution by executing the embedded monadic value. Or we can stop. Or we can save the state for later. This is very similar to continuation-passing style (and indeed, the <code>InterpM</code> monad is just a special case of a continuation monad).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">InterpM</span> a <span class="fu">=</span> <span class="dt">Result</span> a</a>
<a class="sourceLine" id="cb6-2" title="2">               <span class="fu">|</span> <span class="dt">Error</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-3" title="3">               <span class="fu">|</span> <span class="dt">Step</span> <span class="dt">String</span> (<span class="dt">InterpM</span> a)</a></code></pre></div>
<p>The <code>Monad</code> instance is completely straightforward by the types.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">InterpM</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="fu">return</span> <span class="fu">=</span> <span class="dt">Result</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="fu">fail</span> <span class="fu">=</span> <span class="dt">Error</span></a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="dt">Result</span> x       <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="dt">Error</span> s        <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="dt">Error</span> s</a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="dt">Step</span> desc path <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Step</span> desc (path <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>The <code>Functor</code> and <code>Applicative</code> instances, which are required in GHC versions newer than 7.8, are completely mechanical.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">InterpM</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="fu">fmap</span> <span class="fu">=</span> liftM</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">InterpM</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="fu">pure</span> <span class="fu">=</span> <span class="fu">return</span></a>
<a class="sourceLine" id="cb8-6" title="6">  f <span class="fu">&lt;*&gt;</span> x <span class="fu">=</span> f <span class="ot">`ap`</span> x</a></code></pre></div>
<p>We wrap the <code>Step</code> constructor in a function to create a veneer of abstraction. In principle, the monad could be much more complicated (it would be in most practical implementations), but with a similarly simple interface.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">step ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InterpM</span> a <span class="ot">-&gt;</span> <span class="dt">InterpM</span> a</a>
<a class="sourceLine" id="cb9-2" title="2">step <span class="fu">=</span> <span class="dt">Step</span></a></code></pre></div>
<h2 id="the-interpreter"><a href="#the-interpreter" id="the-interpreter-link" class="titlelink" title="the-interpreter">The Interpreter</a></h2>
<p>We are now ready to implement our Lisp interpreter. First, we define our variable table, which is a mapping from variable names to their values. Values are, of course, just S-expressions.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="dt">VarTable</span> <span class="fu">=</span> [(<span class="dt">String</span>,<span class="dt">SExp</span>)]</a></code></pre></div>
<p>Evaluation with the <code>eval</code> function happens in the context of a variable table, and evaluates an S-expression, giving back an <code>InterpM</code> action. Thus, we might get a result (if evaluation finished), an error, or a stepping point, where we can choose to continue execution.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">eval ::</span> <span class="dt">VarTable</span> <span class="ot">-&gt;</span> <span class="dt">SExp</span> <span class="ot">-&gt;</span> <span class="dt">InterpM</span> <span class="dt">SExp</span></a></code></pre></div>
<p>We will need a few building blocks before we can define the <code>eval</code> function itself. And most importantly, we must understand how Lisp is evaluated. A Lisp <em>form</em> is a list <code>(x y z...)</code>. The first element of the list is called the <em>operator</em>, and the remaining elements the <em>operands</em>. In the general case, the operator is the name of a function, and the operands are recursively evaluated, with the operator applied to the results. However, some forms are <em>special forms</em>, which have specialised evaluation semantics. Our Lisp dialect has a few of those, which we will discuss when we get to them.</p>
<p>The most basic evaluation rule is that the operator of a form must be a symbol, so we define a helper function for determining whether an S-expression is a symbol.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">isSymbol ::</span> <span class="dt">SExp</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-2" title="2">isSymbol (<span class="dt">Symbol</span> v) <span class="fu">=</span> <span class="dt">Just</span> v</a>
<a class="sourceLine" id="cb12-3" title="3">isSymbol _          <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>The operands of a form must constitute a valid list, which we can check using the previously defined <code>fromSExp</code> function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">getOperands ::</span> <span class="dt">SExp</span> <span class="ot">-&gt;</span> <span class="dt">InterpM</span> [<span class="dt">SExp</span>]</a>
<a class="sourceLine" id="cb13-2" title="2">getOperands <span class="fu">=</span> <span class="fu">maybe</span> (<span class="fu">fail</span> <span class="st">&quot;Invalid form&quot;</span>) <span class="fu">return</span> <span class="fu">.</span> fromSExp</a></code></pre></div>
<p>Once we have the name of a function, we must also be able to call it. This is the job of <code>getFunction</code>, which returns a Haskell function corresponding to a named Lisp function.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">getFunction ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InterpM</span> (<span class="dt">VarTable</span> <span class="ot">-&gt;</span> [<span class="dt">SExp</span>] <span class="ot">-&gt;</span> <span class="dt">InterpM</span> <span class="dt">SExp</span>)</a></code></pre></div>
<p>Before we give <code>getFunction</code> a definition, let’s define <code>eval</code>. We use <code>step</code> to create a stepping point before any S-expression is evaluated, followed by matching on the structure of the S-expression.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">eval vt sexp <span class="fu">=</span> step (<span class="st">&quot;Evaluating &quot;</span> <span class="fu">++</span> <span class="fu">show</span> sexp) <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="kw">case</span> sexp <span class="kw">of</span></a></code></pre></div>
<p>The simplest case is a number, which evaluates to itself.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">    <span class="dt">Number</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Number</span> x</a></code></pre></div>
<p>Symbols are looked up in the variable table.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">    <span class="dt">Symbol</span> v <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="fu">lookup</span> v vt <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-2" title="2">                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Unknown variable: &quot;</span> <span class="fu">++</span> v</a>
<a class="sourceLine" id="cb17-3" title="3">                    <span class="dt">Just</span> se <span class="ot">-&gt;</span> <span class="fu">return</span> se</a></code></pre></div>
<p>The only special form in our Lisp is <code>quote</code>, which produces its single operand <em>without evaluating it</em>. Thus, <code>(quote a)</code> evaluates to the symbol <code>a</code>, and <code>(quote (a b c))</code> to the list <code>(a b c)</code>. This special form is how we write literal Lisp data.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">    <span class="dt">Cons</span> (<span class="dt">Symbol</span> <span class="st">&quot;quote&quot;</span>) cdr <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-2" title="2">      <span class="kw">case</span> fromSExp cdr <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-3" title="3">        <span class="dt">Just</span> [x] <span class="ot">-&gt;</span> <span class="fu">return</span> x</a>
<a class="sourceLine" id="cb18-4" title="4">        _        <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Bad arguments to quote: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> cdr</a></code></pre></div>
<p>If the operator is not <code>quote</code>, then it must be the name of a function. We use <code>getFunction</code> to get the corresponding Haskell function, evaluate the operands, then apply the function to the evaluated operands. We also create a stepping point, just for good measure.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">    <span class="dt">Cons</span> (<span class="dt">Symbol</span> operator) rest <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-2" title="2">      operator' <span class="ot">&lt;-</span> getFunction operator</a>
<a class="sourceLine" id="cb19-3" title="3">      args <span class="ot">&lt;-</span> getOperands rest</a>
<a class="sourceLine" id="cb19-4" title="4">      args' <span class="ot">&lt;-</span> <span class="fu">mapM</span> (eval vt) args</a>
<a class="sourceLine" id="cb19-5" title="5">      step (<span class="st">&quot;Applying &quot;</span> <span class="fu">++</span> operator <span class="fu">++</span> <span class="st">&quot; to &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (toSExp args')) <span class="fu">$</span></a>
<a class="sourceLine" id="cb19-6" title="6">        operator' vt args'</a></code></pre></div>
<p>If none of the previous cases matched, then the S-expression must be malformed.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">    <span class="dt">Cons</span> car cdr <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-2" title="2">     <span class="fu">fail</span> (<span class="st">&quot;Bad form: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (<span class="dt">Cons</span> car cdr))</a></code></pre></div>
<p>The definition of <code>getFunction</code> is mostly uninteresting. This is where we put built-in functions. One of those is <code>list</code>, which takes any number of arguments, and simply returns them.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">getFunction <span class="st">&quot;list&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> <span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> <span class="fu">.</span> toSExp</a></code></pre></div>
<p>The <code>cons</code> function takes two arguments, and returns a cons cell containing them.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1">getFunction <span class="st">&quot;cons&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-3" title="3">    [x, y] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Cons</span> x y</a>
<a class="sourceLine" id="cb22-4" title="4">    _      <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Wrong number of arguments to cons: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a></code></pre></div>
<p>The functions <code>car</code> and <code>cdr</code> are used to access the components of a cons cell.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">getFunction <span class="st">&quot;car&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-3" title="3">    [<span class="dt">Cons</span> car _] <span class="ot">-&gt;</span> <span class="fu">return</span> car</a>
<a class="sourceLine" id="cb23-4" title="4">    _            <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Bad arguments to car: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a>
<a class="sourceLine" id="cb23-5" title="5">getFunction <span class="st">&quot;cdr&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-7" title="7">    [<span class="dt">Cons</span> _ cdr] <span class="ot">-&gt;</span> <span class="fu">return</span> cdr</a>
<a class="sourceLine" id="cb23-8" title="8">    _            <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Bad arguments to cdr: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a></code></pre></div>
<p>We also have the usual arithmetic operators on numbers.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1">getFunction <span class="st">&quot;+&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-3" title="3">    [<span class="dt">Number</span> x, <span class="dt">Number</span> y] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Number</span> <span class="fu">$</span> x<span class="fu">+</span>y</a>
<a class="sourceLine" id="cb24-4" title="4">    _                    <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Invalid arguments to +: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a>
<a class="sourceLine" id="cb24-5" title="5">getFunction <span class="st">&quot;-&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-6" title="6">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-7" title="7">    [<span class="dt">Number</span> x, <span class="dt">Number</span> y] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Number</span> <span class="fu">$</span> x<span class="fu">-</span>y</a>
<a class="sourceLine" id="cb24-8" title="8">    _                    <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Invalid arguments to -: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a>
<a class="sourceLine" id="cb24-9" title="9">getFunction <span class="st">&quot;/&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-10" title="10">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-11" title="11">    [<span class="dt">Number</span> x, <span class="dt">Number</span> y] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Number</span> <span class="fu">$</span> x <span class="ot">`div`</span> y</a>
<a class="sourceLine" id="cb24-12" title="12">    _                    <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Invalid arguments to /: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a>
<a class="sourceLine" id="cb24-13" title="13">getFunction <span class="st">&quot;*&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \_ args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-14" title="14">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-15" title="15">    [<span class="dt">Number</span> x, <span class="dt">Number</span> y] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Number</span> <span class="fu">$</span> x<span class="fu">*</span>y</a>
<a class="sourceLine" id="cb24-16" title="16">    _                    <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Invalid arguments to *: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a></code></pre></div>
<p>The most interesting built-in function is <code>apply</code>. The <code>apply</code> function takes two arguments: the first represents a function, the second a list of arguments, and <code>apply</code> applies the function to those arguments. The simplest case is the one where the first argument is a symbol - we just call the function with that name.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">getFunction <span class="st">&quot;apply&quot;</span> <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> \vt args <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-3" title="3">    [<span class="dt">Symbol</span> fname, fargs]</a>
<a class="sourceLine" id="cb25-4" title="4">      <span class="fu">|</span> <span class="dt">Just</span> fargs' <span class="ot">&lt;-</span> fromSExp fargs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-5" title="5">          f <span class="ot">&lt;-</span> getFunction fname</a>
<a class="sourceLine" id="cb25-6" title="6">          step (<span class="st">&quot;Calling &quot;</span> <span class="fu">++</span> fname <span class="fu">++</span> <span class="st">&quot; with arguments &quot;</span> <span class="fu">++</span> <span class="fu">show</span> fargs) <span class="fu">$</span></a>
<a class="sourceLine" id="cb25-7" title="7">            f vt fargs'</a></code></pre></div>
<p>More interestingly, we also permit the function argument to be a <em>lambda form</em>. This is an S-expression with the structure <code>(lambda (params...) body)</code>. When <code>apply</code> is given a lambda form, it binds the named parameters to given arguments (they must match in number) and evaluates the body.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">    [<span class="dt">Cons</span> (<span class="dt">Symbol</span> <span class="st">&quot;lambda&quot;</span>) rest, fargs]</a>
<a class="sourceLine" id="cb26-2" title="2">      <span class="fu">|</span> <span class="dt">Just</span> fargs' <span class="ot">&lt;-</span> fromSExp fargs,</a>
<a class="sourceLine" id="cb26-3" title="3">        <span class="dt">Just</span> [params, body] <span class="ot">&lt;-</span> fromSExp rest,</a>
<a class="sourceLine" id="cb26-4" title="4">        <span class="dt">Just</span> params' <span class="ot">&lt;-</span> <span class="fu">mapM</span> isSymbol <span class="fu">=&lt;&lt;</span> fromSExp params,</a>
<a class="sourceLine" id="cb26-5" title="5">        <span class="fu">length</span> params' <span class="fu">==</span> <span class="fu">length</span> fargs' <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-6" title="6">       step (<span class="st">&quot;Calling lambda with parameters &quot;</span> <span class="fu">++</span> <span class="fu">show</span> params <span class="fu">++</span></a>
<a class="sourceLine" id="cb26-7" title="7">             <span class="st">&quot; bound to &quot;</span> <span class="fu">++</span> <span class="fu">show</span> fargs) <span class="fu">$</span></a>
<a class="sourceLine" id="cb26-8" title="8">         eval (<span class="fu">zip</span> params' fargs' <span class="fu">++</span> vt) body</a>
<a class="sourceLine" id="cb26-9" title="9">    _ <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;Invalid arguments to funcall: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> args</a></code></pre></div>
<p>If <code>apply</code> is given anything else, it reports an error.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">getFunction f <span class="fu">=</span> <span class="fu">fail</span> (<span class="st">&quot;Unknown function: &quot;</span> <span class="fu">++</span> f)</a></code></pre></div>
<p>Apart from the calls to <code>step</code>, the above Lisp interpreter is completely bog-standard. The single-stepping capability has not intruded upon the way we structured the functions. Yet, the capability is there, and we can use it to create an interesting frontend, where the user is prompted before every evaluation step.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">stepIO ::</span> <span class="dt">SExp</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb28-2" title="2">stepIO <span class="fu">=</span> loop <span class="fu">.</span> eval <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb28-3" title="3">  <span class="kw">where</span> loop (<span class="dt">Result</span> v) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb28-4" title="4">          <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;Evaluation finished.  Result: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> v</a>
<a class="sourceLine" id="cb28-5" title="5">        loop (<span class="dt">Error</span> err) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb28-6" title="6">          <span class="fu">error</span> err</a>
<a class="sourceLine" id="cb28-7" title="7">        loop (<span class="dt">Step</span> desc s) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb28-8" title="8">          <span class="fu">putStrLn</span> <span class="fu">$</span> desc <span class="fu">++</span> <span class="st">&quot; (press Enter to continue)&quot;</span></a>
<a class="sourceLine" id="cb28-9" title="9">          _ <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb28-10" title="10">          loop s</a></code></pre></div>
<p>This frontend could easily be made much more sophisticated - for example, it could allow the user to move backwards in time, or inspect the variable table (although this would require an extension of the monad).</p>
<h2 id="a-small-parser"><a href="#a-small-parser" id="a-small-parser-link" class="titlelink" title="a-small-parser">A Small Parser</a></h2>
<p>To tie it all together, we define a quick little Lisp parser. Note that this one does not support the dotted-pair notation for conses.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="ot">token ::</span> <span class="dt">ReadP</span> a <span class="ot">-&gt;</span> <span class="dt">ReadP</span> a</a>
<a class="sourceLine" id="cb29-2" title="2">token p <span class="fu">=</span> skipSpaces <span class="fu">&gt;&gt;</span> p</a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="ot">schar ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">ReadP</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb29-5" title="5">schar <span class="fu">=</span> token <span class="fu">.</span> char</a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="ot">numberOrSymbol ::</span> <span class="dt">ReadP</span> <span class="dt">SExp</span></a>
<a class="sourceLine" id="cb29-8" title="8">numberOrSymbol <span class="fu">=</span> token <span class="fu">$</span> <span class="kw">do</span> s <span class="ot">&lt;-</span> munch1 <span class="fu">$</span> \c <span class="ot">-&gt;</span> <span class="fu">not</span> (<span class="fu">isSpace</span> c <span class="fu">||</span> c <span class="ot">`elem`</span> <span class="st">&quot;()&quot;</span>)</a>
<a class="sourceLine" id="cb29-9" title="9">                            <span class="fu">return</span> <span class="fu">$</span> <span class="kw">if</span> <span class="fu">all</span> <span class="fu">isDigit</span> s <span class="kw">then</span> <span class="dt">Number</span> <span class="fu">$</span> <span class="fu">read</span> s</a>
<a class="sourceLine" id="cb29-10" title="10">                                     <span class="kw">else</span> <span class="dt">Symbol</span> s</a>
<a class="sourceLine" id="cb29-11" title="11"><span class="ot">readSExp ::</span> <span class="dt">ReadP</span> <span class="dt">SExp</span></a>
<a class="sourceLine" id="cb29-12" title="12">readSExp <span class="fu">=</span> numberOrSymbol</a>
<a class="sourceLine" id="cb29-13" title="13">       <span class="fu">+++</span> between (schar <span class="ch">'('</span>) (schar <span class="ch">')'</span>) sexps</a>
<a class="sourceLine" id="cb29-14" title="14">  <span class="kw">where</span> sexps <span class="fu">=</span> many readSExp <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">.</span> toSExp</a>
<a class="sourceLine" id="cb29-15" title="15"></a>
<a class="sourceLine" id="cb29-16" title="16"><span class="ot">parseString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">SExp</span></a>
<a class="sourceLine" id="cb29-17" title="17">parseString s <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-18" title="18">  <span class="kw">case</span> readP_to_S (<span class="kw">do</span> {e <span class="ot">&lt;-</span> readSExp; token eof; <span class="fu">return</span> e}) s <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-19" title="19">      [(e, [])] <span class="ot">-&gt;</span> <span class="dt">Right</span> e</a>
<a class="sourceLine" id="cb29-20" title="20">      _         <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="st">&quot;Parse error&quot;</span></a></code></pre></div>
<h2 id="command-line-usage"><a href="#command-line-usage" id="command-line-usage-link" class="titlelink" title="command-line-usage">Command Line Usage</a></h2>
<p>Finally, we create a <code>main</code> function that allows us to run this very file as a Haskell program.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb30-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-3" title="3">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb30-4" title="4">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-5" title="5">    [f] <span class="ot">-&gt;</span> <span class="kw">do</span> s <span class="ot">&lt;-</span> <span class="fu">readFile</span> f</a>
<a class="sourceLine" id="cb30-6" title="6">              <span class="kw">case</span> parseString s <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-7" title="7">                <span class="dt">Right</span> sexp <span class="ot">-&gt;</span> stepIO sexp</a>
<a class="sourceLine" id="cb30-8" title="8">                <span class="dt">Left</span> err   <span class="ot">-&gt;</span> <span class="fu">error</span> err</a>
<a class="sourceLine" id="cb30-9" title="9">    _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Needs an argument.&quot;</span></a></code></pre></div>
<p>While this Lisp dialect is quite limited (in particular, dynamic scoping is an anachronism), it is still more expressive than you may think. We can use lambda forms to simulate local variables and named functions. For example, if we put the following program in <code>double.lisp</code>:</p>
<pre><code>(apply (quote (lambda (square)
                 (apply square (list 2))))
 (list (quote (lambda (x) (* x x)))))</code></pre>
<p>Then we can run our interpreter on it as such:</p>
<pre><code>$ runhaskell stepping.lhs double.lisp
Evaluating (apply (quote (lambda (square) (apply square (list 2)))) (list (quote (lambda (x) (* x x))))) (press Enter to continue)

Evaluating (quote (lambda (square) (apply square (list 2)))) (press Enter to continue)

Evaluating (list (quote (lambda (x) (* x x)))) (press Enter to continue)

Evaluating (quote (lambda (x) (* x x))) (press Enter to continue)

Applying list to ((lambda (x) (* x x))) (press Enter to continue)

Applying apply to ((lambda (square) (apply square (list 2))) ((lambda (x) (* x x)))) (press Enter to continue)

Calling lambda with parameters (square) bound to ((lambda (x) (* x x))) (press Enter to continue)

Evaluating (apply square (list 2)) (press Enter to continue)

Evaluating square (press Enter to continue)

Evaluating (list 2) (press Enter to continue)

Evaluating 2 (press Enter to continue)

Applying list to (2) (press Enter to continue)

Applying apply to ((lambda (x) (* x x)) (2)) (press Enter to continue)

Calling lambda with parameters (x) bound to (2) (press Enter to continue)

Evaluating (* x x) (press Enter to continue)

Evaluating x (press Enter to continue)

Evaluating x (press Enter to continue)

Applying * to (2 2) (press Enter to continue)

Evaluation finished.  Result: 4</code></pre>
<h2 id="limitations-and-extensions"><a href="#limitations-and-extensions" id="limitations-and-extensions-link" class="titlelink" title="limitations-and-extensions">Limitations and Extensions</a></h2>
<p>The interpreter implemented here is a toy. The primary limitation is that the monad is entirely special-purpose. We do not re-use a standard error monad, nor do we use a <code>Reader</code> for passing around the variable table. Futhermore, the stepping points give us too little information. One bit that would be nice to have would be the <em>evaluation depth</em>, which would allow us to create a command for saying “evaluate the current expression to completeness without prompting me about the intermediate steps”. This command would be implemented by always following <code>Step</code>s (without prompting) until the starting depth is reached again. Such a facility is crucial for fast-forwarding to the interesting parts of the computation.</p>
    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
