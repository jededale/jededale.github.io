<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hakyll tutorial</title>
    <link rel="stylesheet" href="../../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href="../.././writings/guides/hakyll.lhs">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../../blog/">blog/</a></li><li><a href="../../hacks/">hacks/</a></li><li><a href="../../links.html">links</a></li><li><a href="../../me/">me/</a></li><li><a href="../../programs/">programs/</a></li><li><a href="../../projects/">projects/</a></li><li><a href="../../writings/" class="thisPage">writings/</a></li></ul><ul class="menu1"><li><a href="../../writings/braces.html">braces</a></li><li><a href="../../writings/flights.html">flights</a></li><li><a href="../../writings/fountain_pens.html">fountain_pens</a></li><li><a href="../../writings/guides/" class="thisPage">guides/</a></li><li><a href="../../writings/languages.html">languages</a></li><li><a href="../../writings/primes.html">primes</a></li><li><a href="../../writings/scripting.html">scripting</a></li><li><a href="../../writings/semicolons.html">semicolons</a></li></ul><ul class="menu2"><li><a href="../../writings/guides/gateway.html">gateway</a></li><li><a href="../../writings/guides/hakyll.html" class="thisPage">hakyll</a></li><li><a href="../../writings/guides/mime.html">mime</a></li><li><a href="../../writings/guides/nixos_pass.html">nixos_pass</a></li><li><a href="../../writings/guides/plan_9_tools.html">plan_9_tools</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1 id="opinionated-hakyll-tutorial"><a href="#opinionated-hakyll-tutorial" id="opinionated-hakyll-tutorial-link" class="titlelink" title="opinionated-hakyll-tutorial">Opinionated Hakyll Tutorial</a></h1>
<p>This guide (which is also a Literate Haskell program) describes basic Hakyll metaphors in a way that I would have found useful when first learning Hakyll, using a working example site to illustrate the concepts. I was using Hakyll 4.6.8.1 and GHC 7.8.1 when writing this article.</p>
<h2 id="introduction"><a href="#introduction" id="introduction-link" class="titlelink" title="introduction">Introduction</a></h2>
<p><a href="http://jaspervdj.be/hakyll/">Hakyll</a> is the static web site generator used to create this site. You use it by defining the behaviour and structure of your site as a Haskell program that uses various facilities exposed by the Hakyll modules, a style familiar to users of <a href="http://xmonad.org/">Xmonad</a>. A number of <a href="http://jaspervdj.be/hakyll/tutorials.html">tutorials</a> are available on the Hakyll website, but when I was trying to learn Hakyll (some years ago), I was sorely missing a guide aimed at experienced Haskell programmers, one that defined the basic abstractions and metaphors in terms of the data types actually exposed by Hakyll. After much trial and error, I eventually came to understand what was going on, and decided to document it as the kind of tutorial that I would have found useful. I still recommend skimming the other tutorials, as I will probably skip things that I don’t find very interesting. In fact, this should probably be considered an “advanced tutorial” (that certainly sounds much better than “stream-of-consciousness snapshot”).</p>
<h2 id="modules"><a href="#modules" id="modules-link" class="titlelink" title="modules">Modules</a></h2>
<p>Hakyll is used by compiling and running a program in the directory containing the input files, which then generates the site as a set of output files. Hence, we define a <code>Main</code> module that exports a <code>main</code> function and imports all the modules we’ll need. The <code>OverloadedStrings</code> language extension, as a small convenience, lets us write <code>&quot;*.md&quot;</code> instead of <code>parseGlob &quot;*.md&quot;</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">module</span> <span class="dt">Main</span>(main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Hakyll</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a></code></pre></div>
<h2 id="basic-operation"><a href="#basic-operation" id="basic-operation-link" class="titlelink" title="basic-operation">Basic Operation</a></h2>
<p>Fundamentally, Hakyll is extremely simple: it is an association between <a href="https://hackage.haskell.org/package/hakyll-4.6.9.0/docs/Hakyll-Core-Identifier.html">Identifier</a>s and <a href="https://hackage.haskell.org/package/hakyll-4.6.9.0/docs/Hakyll-Core-Compiler.html">Compiler</a>s, and everything else is just scaffolding around that. An identifier is just that: a name consisting of an optional “group” and a mandatory “path”, which need not be a file path, but often is. A compiler is an action in the monad <code>Compiler</code>. When the site is generated, the compiler for each identifier is executed. A compiler can in principle do anything to generate its output, but one interesting thing it can do is ask for the compilation result some other (known) identifier. Hakyll will automatically run the compilers in the proper order such that these requirements are satisfied, although cycles are forbidden. Since you cannot in general know the type of values generated by the compiler of some arbitrary identifier, you can get a type error at runtime if you ask for the compilation result as a different type than the compiler produces (there are some typeclass constraints that I’ll get into later).</p>
<p>The output from a compiler is not necessarily put anywhere unless another compiler asks for it, but it is possible to define a “<a href="https://hackage.haskell.org/package/hakyll-4.6.9.0/docs/Hakyll-Core-Routes.html">route</a>” for a compiler, which causes Hakyll to write the result to a file in the site directory. The route is not part of the compiler itself, but defined as an association of the identifier. Routes are the way we can map, for example, a Markdown file to the HTML file it should become in the generated site.</p>
<h2 id="rules"><a href="#rules" id="rules-link" class="titlelink" title="rules">Rules</a></h2>
<p>When working with Hakyll in practise, you will define compilers though a monadic DSL incarnated in the <a href="https://hackage.haskell.org/package/hakyll-4.6.9.0/docs/Hakyll-Core-Rules.html">Rules</a> monad. This monad makes it easy to apply similar compilers to all files matching some given pattern. For example, let us define a rule that copies the <code>style.css</code> file verbatim into our site.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">compileCss ::</span> <span class="dt">Rules</span> ()</a>
<a class="sourceLine" id="cb2-2" title="2">compileCss <span class="fu">=</span> match <span class="st">&quot;style.css&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-3" title="3">  route   idRoute</a>
<a class="sourceLine" id="cb2-4" title="4">  _ <span class="ot">&lt;-</span> compile copyFileCompiler</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="fu">return</span> ()</a></code></pre></div>
<p>The <code>return ()</code> is to make the type <code>Rules</code>, rather than <code>RulesM (Pattern CopyFile)</code> – <code>Rules</code> is just <code>RulesM ()</code>. The <code>match</code> function runs the given rules for each file in its match, although the above will only match exactly one file, namely <code>style.css</code> in the same directory as our Hakyll source file. In general terms, the <code>compile</code> action associates the given compiler with each of the identifiers matching the current pattern. The set of possible identifiers (which are then filtered by the pattern) is taken from the <em>files</em> (not directories) in the directory from which Hakyll is run. The compiler given to <code>compile</code> must take a <code>Resource</code> as its input, which is really just a wrapper around an identifier guaranteed to refer to a file.</p>
<h2 id="a-menu"><a href="#a-menu" id="a-menu-link" class="titlelink" title="a-menu">A Menu</a></h2>
<p>Let’s do something more complicated: we want our site to contain a bunch of pages, but all of them should contain a complete list (a menu) of all pages on the site. This sounds like a problem: in order to generate one page, we must already have seen every other page, which violates the requirement that compiler dependencies must be acyclic. The solution is to use two logical passes: first run a set of compilers that somehow generate a list of all pages, then actually generate the content for each page while including that information. This is possible since the menu does not need to know the <em>content</em> of each page, but only its eventual location on the site, which in Hakyll terms is the <em>route</em> for each <em>identifier</em> corresponding to an input file. So far, so good, but how do we easily generate such lists? To begin with, we define a pattern that matches all the content pages on our site.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">content ::</span> <span class="dt">Pattern</span></a>
<a class="sourceLine" id="cb3-2" title="2">content <span class="fu">=</span> <span class="st">&quot;**.md&quot;</span></a></code></pre></div>
<p>This pattern matches all <code>.md</code> files, including those in subdirectories to any depth. Our site may have other files - images and other resources - but we do not want these to show up in the menu anyway.</p>
<p>When we try to define rules for storing menu information, we may run into the problem that the compiler we pass to <code>compile</code> is really quite restricted in its output type: it has to implement various type classes permitting serialisation, as it could in principle be asked to write its result to a file. In this case we’re in luck, as plain <code>String</code>s implement the required instances. A second problem is that we conceptually wish to associate two compilers with each input file - one that generates its data for the menu, and one that actually renders the page to HTML. The solution is to tag the identifiers related to the menu compilers with a version (here, <code>&quot;menu&quot;</code>), which makes them different from the identifiers used for the actual content, which have no version.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">compileMenu ::</span> <span class="dt">Rules</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">compileMenu <span class="fu">=</span> match content <span class="fu">$</span> version <span class="st">&quot;menu&quot;</span> <span class="fu">$</span> compile destination</a></code></pre></div>
<p>For every file that matches the <code>content</code> pattern, we create an identifier corresponding of the file path and the version <code>&quot;menu&quot;</code>. This identifier we associate with the compiler <code>destination</code>. It is important to note that <code>match</code> filters the <em>input</em>, whereas <code>version</code> modifies the identifiers of the <em>output</em>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">destination ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb5-2" title="2">destination <span class="fu">=</span> setVersion <span class="dt">Nothing</span> <span class="fu">&lt;$&gt;</span> getUnderlying</a>
<a class="sourceLine" id="cb5-3" title="3">              <span class="fu">&gt;&gt;=</span> getRoute</a>
<a class="sourceLine" id="cb5-4" title="4">              <span class="fu">&gt;&gt;=</span> makeItem <span class="fu">.</span> fromMaybe <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>The <code>destination</code> compiler does not use its underlying file for anything, but instead obtains the identifier being compiled, setting the version of that identifier to <code>Nothing</code>, getting the route for the resulting identifier, and if that identifier doesn’t exist (the route is <code>Nothing</code>), returning the empty string. This is a a bit of a hack, but we don’t really expect getRouteFor to ever return <code>Nothing</code>, as that would mean we have been asked to add a menu entry for a file that will not exist on the site. Since the only difference between the identifiers used for generating the menu and the content is that the latter have version <code>Nothing</code>, this will compute the output path of the compiler responsible for generating the content for the respective file. The reason this works is because you do not need to run the compiler in order to determine where it will put its output - that is defined in the <code>Rules</code> DSL, and hence available simply by querying the identifier.</p>
<h2 id="using-the-menu"><a href="#using-the-menu" id="using-the-menu-link" class="titlelink" title="using-the-menu">Using the Menu</a></h2>
<p>The rule for defining our content pages is quite simple. We replace the existing extension (<code>md</code> according to the <code>content</code> pattern) with <code>html</code>, then pass the page through a three-step compiler that first converts the page from Markdown to HTML, then applies an HTML template, then finally converts absolute URLs into relative URLs so the resulting files can be put anywhere (don’t worry about this last stage, it’s not important). To understand how <code>loadAndApplyTemplate</code> works, we first have to understand Hakyll templates and contexts. Templates are simply files in which variables can be written as <code>$var$</code>. When applying the template, each such instance is replaced with the value of the corresponding variable in the passed context. Our <code>template.html</code> file will contain the text <code>$menu$</code> where we intend our menu to show up, and hence we need to create a context that contains a <code>menu</code> field containing an HTML-rendering of the menu for that page.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">compileContent ::</span> <span class="dt">Rules</span> ()</a>
<a class="sourceLine" id="cb6-2" title="2">compileContent <span class="fu">=</span> match content <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" title="3">  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  compile <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" title="5">    menu <span class="ot">&lt;-</span> contentContext</a>
<a class="sourceLine" id="cb6-6" title="6">    pandocCompiler</a>
<a class="sourceLine" id="cb6-7" title="7">      <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;template.html&quot;</span> menu</a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="fu">&gt;&gt;=</span> relativizeUrls</a></code></pre></div>
<p>Apart from the <code>menu</code> field, the template also needs some standard fields like <code>&quot;content&quot;</code> and <code>&quot;title&quot;</code>. These are provided by <code>defaultContext</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">contentContext ::</span> <span class="dt">Compiler</span> (<span class="dt">Context</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">contentContext <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" title="3">  menu <span class="ot">&lt;-</span> getMenu</a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="fu">return</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-5" title="5">    defaultContext <span class="ot">`mappend`</span></a>
<a class="sourceLine" id="cb7-6" title="6">    constField <span class="st">&quot;menu&quot;</span> menu</a></code></pre></div>
<p>The <code>getMenu</code> compiler is the one that actually produces the menu. The real trick here is the use of <code>loadAll</code>, which lets us obtain a list of all compiler outputs for identifiers in the <code>&quot;menu&quot;</code> group. That means a list of all routes for our content pages!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">getMenu ::</span> <span class="dt">Compiler</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-2" title="2">getMenu <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" title="3">  menu <span class="ot">&lt;-</span> <span class="fu">map</span> itemBody <span class="fu">&lt;$&gt;</span> loadAll (fromVersion <span class="fu">$</span> <span class="dt">Just</span> <span class="st">&quot;menu&quot;</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">  myRoute <span class="ot">&lt;-</span> getRoute <span class="fu">=&lt;&lt;</span> getUnderlying</a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> myRoute <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-6" title="6">             <span class="dt">Nothing</span> <span class="ot">-&gt;</span> showMenu <span class="st">&quot;&quot;</span> menu</a>
<a class="sourceLine" id="cb8-7" title="7">             <span class="dt">Just</span> me <span class="ot">-&gt;</span> showMenu me menu</a></code></pre></div>
<p><code>showMenu</code> itself is just a plain Haskell function that produces an HTML list with the current page highlighted. In practice, we’d use a proper HTML combinator library, but let’s stick with strings for simplicity.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">showMenu ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> [<span class="dt">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-2" title="2">showMenu this items <span class="fu">=</span> <span class="st">&quot;&lt;ul&gt;&quot;</span><span class="fu">++concatMap</span> li items<span class="fu">++</span><span class="st">&quot;&lt;/ul&gt;&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">where</span> li item <span class="fu">=</span> <span class="st">&quot;&lt;li&gt;&lt;a href=\&quot;/&quot;</span><span class="fu">++</span>item<span class="fu">++</span><span class="st">&quot;\&quot;&gt;&quot;</span><span class="fu">++</span>name item<span class="fu">++</span><span class="st">&quot;&lt;/a&gt;&lt;/li&gt;&quot;</span></a>
<a class="sourceLine" id="cb9-4" title="4">        name item <span class="fu">|</span> item <span class="fu">==</span> this <span class="fu">=</span> <span class="st">&quot;&lt;strong&gt;&quot;</span><span class="fu">++</span>item<span class="fu">++</span><span class="st">&quot;&lt;/strong&gt;&quot;</span></a>
<a class="sourceLine" id="cb9-5" title="5">                  <span class="fu">|</span> <span class="fu">otherwise</span>    <span class="fu">=</span> item</a></code></pre></div>
<p>In order to use a template, we have to tell Hakyll it exists. That’s what the <code>templateCompiler</code> is about. This is not a very interesting definition.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">compileTemplates ::</span> <span class="dt">Rules</span> ()</a>
<a class="sourceLine" id="cb10-2" title="2">compileTemplates <span class="fu">=</span> match <span class="st">&quot;template.html&quot;</span> <span class="fu">$</span> compile templateCompiler</a></code></pre></div>
<p>Finally, the Hakyll main function is written in a rather stylised manner, with <code>hakyll</code> being given a <code>Rules ()</code> monadic action. Note that although I execute <code>compileMenu</code> before <code>compileContent</code> for conceptual reasons, I could swap them around and it would still work.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" title="2">main <span class="fu">=</span> hakyll <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" title="3">         compileCss</a>
<a class="sourceLine" id="cb11-4" title="4">         compileMenu</a>
<a class="sourceLine" id="cb11-5" title="5">         compileContent</a>
<a class="sourceLine" id="cb11-6" title="6">         compileTemplates</a></code></pre></div>
<p>That’s all there is to it. To try it out, download <a href="../../files/hakyll-tutorial.tar.gz">some input files</a>, put this <a href="hakyll.lhs" class="uri">hakyll.lhs</a> into the directory, then run</p>
<pre><code>$ ghc --make hakyll.lhs &amp;&amp; ./hakyll build &amp;&amp; ./hakyll preview 8080</code></pre>
<p>and point your web browser at <code>localhost:8080</code>. The result should be something similar to <a href="hakyll_tutorial_result/">this</a>. If you change the code, remember to run <code>./hakyll clean</code> as well, as Hakyll’s cache system might otherwise not realise that something is different.</p>
<p>You may also want to look at <a href="../../programs/sigkill.html">sigkill.lhs</a>, the program generating my own website.</p>
    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
