<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Shell scripting</title>
    <link rel="stylesheet" href="../css/default.css" type="text/css" media="screen" title="default">
    <link rel="stylesheet" href="../css/syntax.css" type="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="description" content="Troels Henriksen's piece of the web.  Mostly about programming.">
    <meta name="keywords" content="Braintwist, Brainfuck, Lisp, Common Lisp Troels Henriksen, Brainfork, Esoteric programming language, programming, Haskell, functional programming, Futhark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="header">
      <div class="superHeader">

        <div class="right">
          <span class="doNotDisplay">Related sites:</span>
          <ul>
            <li><a href="https://github.com/Athas/sigkill.dk">github</a></li>
            
            <li><a href=".././writings/scripting.md">source</a></li>
            
          </ul>
        </div>

      </div>

      <div class="midHeader">
        <h1 class="headerTitle"><a href="../">SIGKILL <span id="headerSubTitle">-9</span></a></h1>
      </div>

      <div class="subHeader">
        <ul class="menu0"><li><a href="../blog/">blog/</a></li><li><a href="../hacks/">hacks/</a></li><li><a href="../links.html">links</a></li><li><a href="../me/">me/</a></li><li><a href="../programs/">programs/</a></li><li><a href="../projects/">projects/</a></li><li><a href="../writings/" class="thisPage">writings/</a></li></ul><ul class="menu1"><li><a href="../writings/braces.html">braces</a></li><li><a href="../writings/flights.html">flights</a></li><li><a href="../writings/fountain_pens.html">fountain_pens</a></li><li><a href="../writings/guides/">guides/</a></li><li><a href="../writings/languages.html">languages</a></li><li><a href="../writings/primes.html">primes</a></li><li><a href="../writings/scripting.html" class="thisPage">scripting</a></li><li><a href="../writings/semicolons.html">semicolons</a></li></ul>
      </div>
    </div>

    <div id="content">
      <h1 id="shell-scripting-tricks"><a href="#shell-scripting-tricks" id="shell-scripting-tricks-link" class="titlelink" title="shell-scripting-tricks">Shell Scripting Tricks</a></h1>
<p>I like writing shell scripts, even when they are not really appropriate. I will attempt to document a number of tips and tricks on this page. Unless otherwise noted, I will be writing about POSIX-compatible shells, although much can probably be adapted to <code>rc</code> without too much trouble. None of this is cutting edge or particularly unknown, but it’s a handy list of solutions that weren’t immediately obvious to me when I first encountered the problems they solve.</p>
<h2 id="changing-a-file-in-place"><a href="#changing-a-file-in-place" id="changing-a-file-in-place-link" class="titlelink" title="changing-a-file-in-place">Changing a file in-place</a></h2>
<p>A common task in shell scripts is to change some file in place. A shell pipeline is not directly suitable, as for example</p>
<pre><code>cat foo | grep bar &gt; foo</code></pre>
<p>will truncate the file <code>foo</code> before running the pipeline, thus merely deleting its contents. There’s a workaround exploiting shell evaluation order, though:</p>
<pre><code>(rm foo &amp;&amp; grep bar &gt; foo) &lt; foo</code></pre>
<p>When running the above, the shell first opens the file <code>foo</code> for reading, then begins executing the subshell. <code>rm foo</code> unlinks the file from the file system, but Unix file semantics means that the shell will still have it open for reading (it won’t be finally erased until any open file descriptors have been closed). When the shell then evalutes <code>grep bar &gt; foo</code>, <code>foo</code> will be a <em>newly</em> created file, and thus not affect the contents of the “old” <code>foo</code> that is still open. You could also use the <code>sponge</code> program from the <a href="http://kitenet.net/~joey/code/moreutils/">moreutils</a> package, although I believe the above is perfectly elegant.</p>
<p>Both the subshell method and <code>sponge</code> suffer from the same problem, namely that the contents of <code>foo</code> will be entirely replaced by the output of the command, even if the command fails. Consider using <a href="../projects/insitu"><code>insitu</code></a>, which can detect whether the command fails, and not truncate in that case. If you want to be completely safe against data loss, you need to produce all output to a temporary file and overwrite the original at the end, though.</p>
<h2 id="literal-sublines-in-files"><a href="#literal-sublines-in-files" id="literal-sublines-in-files-link" class="titlelink" title="literal-sublines-in-files">Literal sublines in files</a></h2>
<p>You often need to do something to those lines of a file that contain some precise string. If you needed to delete such a line, you’d be tempted to use <code>sed</code>, but then you will have to escape the string in order to embed it within a regular expression. You might eye <code>fgrep -v</code>, but if you don’t need to delete the line, but just change it in some way, that’s still not good enough. My preference so far is to bite the bullet and the biggest hammer in the toolbox:</p>
<pre><code>awk 'index($0,STR)!=0 { /* do whatever */ }' 'STR=any string that you can dream of'</code></pre>
<p>This exploits a slightly obscure Awk facility for defining variables (in this case, <code>STR</code>) from the command line.</p>
<h2 id="multiple-pipes"><a href="#multiple-pipes" id="multiple-pipes-link" class="titlelink" title="multiple-pipes">Multiple pipes</a></h2>
<p>Sometimes you need to start a program with specific file descriptors open. This is easy if you need them bound to files, as you can simply provide the optional file descriptor parameter to the input redirection operator:</p>
<pre><code>prog 3&lt;/path/to/file 4&lt;/path/to/other_file</code></pre>
<p>In other cases, you need a program to continously receive the output of several other programs, but a standard Unix shell pipeline will connect standard outputs to standard inputs, which means that a process cannot more than a single piped input stream. You can work around this by having producers write to named pipes (<code>mkfifo</code>), which can be used like files as above, but this results in the hassle and complexity of file system cleanup. An alternative is to exploit the file descriptor duplication operator (<code>&lt;&amp;</code>) to copy the standard input file descriptor before starting the next stage of the pipeline. The result will be every stage of the pipeline being available in a different file descriptor. An demonstration to clarify:</p>
<pre><code>loop() {
  while true; do echo $1; sleep 1; done
}
loop foo | (loop bar | (loop baz | (cat &lt;&amp;3 &amp; cat &lt;&amp;4 &amp; cat &lt;&amp;5) 5&lt;&amp;0 0&lt;&amp;-) 4&lt;&amp;0 0&lt;&amp;-) 3&lt;&amp;0 0&lt;&amp;-</code></pre>
<p>At each right-hand side of a file descriptor, the standard input stream is copied to another file desciptor, and then closed (with <code>0&lt;&amp;-</code>), which may be necessary to make reading from the new file descriptor reliable, depending on whether any of the programs touch standard input. The innermost program (<code>cat &lt;&amp;3 &amp; cat &lt;&amp;4 &amp; cat &lt;&amp;5</code>) has access to the output of the three producing programs via file descriptors 3, 4 and 5. The parentheses are necessary to ensure the file redirection operators work in the proper subshells.</p>
<p>Of course, the above is rather ugly and cumbersome. The following shell function provides a nicer syntax, but requires you to define each step in the pipeline as a function by itself.</p>
<pre><code>multipipe() {
    if [ $# -eq 1 ]; then
        $1
    else
        cmd=$1
        shift
        fd=$1
        shift
        $cmd | eval multipipe '&quot;$@&quot;' &quot;$fd&lt;&amp;0&quot; &quot;0&lt;&amp;-&quot;
    fi
}

loop() {
    while true; do echo $1; sleep 1; done
}

loopfoo() {
    loop foo
}

loopbar() {
    loop bar
}

loopbaz() {
    loop baz
}

body() {
    cat &lt;&amp;3 &amp; cat &lt;&amp;4 &amp; cat &lt;&amp;5
}

multipipe loopfoo 3 loopbar 4 loopbaz 5 body</code></pre>
    </div>

    <div id="footer">
      <a href="http://jaspervdj.be/hakyll/index.html" id="hakyllLink">Powered by Hakyll</a>

      <span id="dates">
        
        
      </span>
    </div>
  </body>
</html>
